"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var bn_js_1 = __importDefault(require("bn.js"));
var Zns_1 = __importDefault(require("./Zns"));
var Uns_1 = __importDefault(require("./Uns"));
var UdApi_1 = __importDefault(require("./UdApi"));
var publicTypes_1 = require("./types/publicTypes");
var resolutionError_1 = __importStar(require("./errors/resolutionError"));
var DnsUtils_1 = __importDefault(require("./utils/DnsUtils"));
var utils_1 = require("./utils");
var Eip1993Factories_1 = require("./utils/Eip1993Factories");
var Networking_1 = __importDefault(require("./utils/Networking"));
var prepareAndValidate_1 = require("./utils/prepareAndValidate");
var namehash_1 = require("./utils/namehash");
/**
 * Blockchain domain Resolution library - Resolution.
 * @example
 * ```
 * import Resolution from '@unstoppabledomains/resolution';
 *
 * let resolution = new Resolution({ blockchain: {
 *        uns: {
 *           url: "https://mainnet.infura.io/v3/12351245223",
 *           network: "mainnet"
 *        }
 *      }
 *   });
 *
 * let domain = "brad.zil";
 * resolution.addr(domain, "eth").then(addr => console.log(addr));;
 * ```
 */
var Resolution = /** @class */ (function () {
    function Resolution(_a) {
        var _b;
        var _c = (_a === void 0 ? {} : _a).sourceConfig, sourceConfig = _c === void 0 ? undefined : _c;
        var uns = isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns)
            ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns)
            : new Uns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns);
        var zns = isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns)
            ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns)
            : new Zns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns);
        this.serviceMap = (_b = {},
            _b[publicTypes_1.NamingServiceName.UNS] = uns,
            _b[publicTypes_1.NamingServiceName.ZNS] = zns,
            _b);
    }
    /**
     * AutoConfigure the blockchain network for UNS
     * We make a "net_version" JSON RPC call to the blockchain either via url or with the help of given provider.
     * @param sourceConfig - configuration object for uns
     * @returns configured Resolution object
     */
    Resolution.autoNetwork = function (sourceConfig) {
        return __awaiter(this, void 0, void 0, function () {
            var resolution, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        resolution = new this();
                        if (!sourceConfig.uns) return [3 /*break*/, 2];
                        _a = resolution.serviceMap;
                        _b = publicTypes_1.NamingServiceName.UNS;
                        return [4 /*yield*/, Uns_1.default.autoNetwork(sourceConfig.uns)];
                    case 1:
                        _a[_b] = _c.sent();
                        _c.label = 2;
                    case 2: return [2 /*return*/, resolution];
                }
            });
        });
    };
    /**
     * Creates a resolution with configured infura id for uns
     * @param infura - infura project id
     * @param networks - an optional object that describes what network to use when connecting UNS default is mainnet
     */
    Resolution.infura = function (infura, networks) {
        var _a, _b, _c, _d;
        return new this({
            sourceConfig: {
                uns: {
                    locations: {
                        Layer1: {
                            url: utils_1.signedInfuraLink(infura, (_a = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _a === void 0 ? void 0 : _a.locations.Layer1.network),
                            network: ((_b = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _b === void 0 ? void 0 : _b.locations.Layer1.network) || 'mainnet',
                        },
                        Layer2: {
                            url: utils_1.signedInfuraLink(infura, (_c = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _c === void 0 ? void 0 : _c.locations.Layer2.network),
                            network: ((_d = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _d === void 0 ? void 0 : _d.locations.Layer2.network) || 'polygon-mainnet',
                        },
                    },
                },
            },
        });
    };
    /**
     * Creates a resolution instance with configured provider
     * @param networks - an object that describes what network to use when connecting UNS or ZNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    Resolution.fromResolutionProvider = function (networks) {
        if (networks.uns) {
            return this.fromEthereumEip1193Provider({
                uns: networks.uns,
            });
        }
        if (networks.zns) {
            return this.fromZilliqaProvider(networks.zns.provider, networks);
        }
        throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
            providerMessage: 'Must specify network for uns or zns',
        });
    };
    /**
     * Creates a resolution instance with configured provider
     * @param networks - an object that describes what network to use when connecting UNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    Resolution.fromEthereumEip1193Provider = function (networks) {
        var sourceConfig = {};
        if (networks.uns) {
            sourceConfig.uns = {
                locations: {
                    Layer1: {
                        provider: networks.uns.locations.Layer1.provider,
                        network: networks.uns.locations.Layer1.network || 'mainnet',
                    },
                    Layer2: {
                        provider: networks.uns.locations.Layer2.provider,
                        network: networks.uns.locations.Layer2.network || 'polygon-mainnet',
                    },
                },
            };
        }
        return new this({
            sourceConfig: sourceConfig,
        });
    };
    /**
     * Creates a resolution instance with configured provider
     * @param provider - any provider compatible with EIP-1193
     * @param networks - an optional object that describes what network to use when connecting ZNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    Resolution.fromZilliqaProvider = function (provider, networks) {
        var _a;
        return new this({
            sourceConfig: {
                zns: { provider: provider, network: ((_a = networks === null || networks === void 0 ? void 0 : networks.zns) === null || _a === void 0 ? void 0 : _a.network) || 'mainnet' },
            },
        });
    };
    /**
     * Create a resolution instance from web3 0.x version provider
     * @param networks - Ethereum network configuration with 0.x version provider from web3 ( must implement sendAsync(payload, callback) )
     * @see https://github.com/ethereum/web3.js/blob/0.20.7/lib/web3/httpprovider.js#L116
     */
    Resolution.fromWeb3Version0Provider = function (networks) {
        return this.fromEthereumEip1193Provider({
            uns: networks.uns
                ? {
                    locations: {
                        Layer1: {
                            network: networks.uns.locations.Layer1.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(networks.uns.locations.Layer1.provider),
                        },
                        Layer2: {
                            network: networks.uns.locations.Layer2.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(networks.uns.locations.Layer2.provider),
                        },
                    },
                }
                : undefined,
        });
    };
    /**
     * Create a resolution instance from web3 1.x version provider
     * @param networks - an optional object with 1.x version provider from web3 ( must implement send(payload, callback) ) that describes what network to use when connecting UNS default is mainnet
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-helpers/types/index.d.ts#L165
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-providers-http/src/index.js#L95
     */
    Resolution.fromWeb3Version1Provider = function (networks) {
        return this.fromEthereumEip1193Provider({
            uns: networks.uns
                ? {
                    locations: {
                        Layer1: {
                            network: networks.uns.locations.Layer1.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(networks.uns.locations.Layer1.provider),
                        },
                        Layer2: {
                            network: networks.uns.locations.Layer2.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(networks.uns.locations.Layer2.provider),
                        },
                    },
                }
                : undefined,
        });
    };
    /**
     * Creates instance of resolution from provider that implements Ethers Provider#call interface.
     * This wrapper support only `eth_call` method for now, which is enough for all the current Resolution functionality
     * @param networks - an object that describes what network to use when connecting UNS default is mainnet
     * @see https://github.com/ethers-io/ethers.js/blob/v4-legacy/providers/abstract-provider.d.ts#L91
     * @see https://github.com/ethers-io/ethers.js/blob/v5.0.4/packages/abstract-provider/src.ts/index.ts#L224
     * @see https://docs.ethers.io/ethers.js/v5-beta/api-providers.html#jsonrpcprovider-inherits-from-provider
     * @see https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
     */
    Resolution.fromEthersProvider = function (networks) {
        return this.fromEthereumEip1193Provider({
            uns: networks.uns
                ? {
                    locations: {
                        Layer1: {
                            network: networks.uns.locations.Layer1.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromEthersProvider(networks.uns.locations.Layer1.provider),
                        },
                        Layer2: {
                            network: networks.uns.locations.Layer2.network,
                            provider: Eip1993Factories_1.Eip1993Factories.fromEthersProvider(networks.uns.locations.Layer2.provider),
                        },
                    },
                }
                : undefined,
        });
    };
    /**
     * Resolves given domain name to a specific currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker like BTC, ETH, ZIL
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an address
     */
    Resolution.prototype.addr = function (domain, ticker) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.record(domain, "crypto." + ticker.toUpperCase() + ".address")];
            });
        });
    };
    /**
     * Read multi-chain currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker (USDT, FTM, etc.)
     * @param chain - chain version, usually means blockchain ( ERC20, BEP2, OMNI, etc. )
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an adress
     */
    Resolution.prototype.multiChainAddr = function (domain, ticker, chain) {
        return __awaiter(this, void 0, void 0, function () {
            var method, recordKey;
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                method = this.getNamingMethodOrThrow(domain);
                recordKey = "crypto." + ticker.toUpperCase() + ".version." + chain.toUpperCase() + ".address";
                return [2 /*return*/, method.record(domain, recordKey)];
            });
        });
    };
    /**
     * Resolves given domain name to a verified twitter handle
     * @async
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]] if twitter is not found
     * @returns A promise that resolves in a verified twitter handle
     */
    Resolution.prototype.twitter = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                method = this.getNamingMethodOrThrow(domain);
                return [2 /*return*/, method.twitter(domain)];
            });
        });
    };
    /**
     * Resolve a chat id from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns A promise that resolves in chatId
     */
    Resolution.prototype.chatId = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.record(domain, 'gundb.username.value')];
            });
        });
    };
    /**
     * Resolve a gundb public key from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns a promise that resolves in gundb public key
     */
    Resolution.prototype.chatPk = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.record(domain, 'gundb.public_key.value')];
            });
        });
    };
    /**
     * Resolves the IPFS hash configured for domain records on ZNS
     * @param domain - domain name
     * @throws [[ResolutionError]]
     */
    Resolution.prototype.ipfsHash = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                return [2 /*return*/, this.getPreferableNewRecord(domain, 'dweb.ipfs.hash', 'ipfs.html.value')];
            });
        });
    };
    /**
     * Resolves the httpUrl attached to domain
     * @param domain - domain name
     */
    Resolution.prototype.httpUrl = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                return [2 /*return*/, this.getPreferableNewRecord(domain, 'browser.redirect_url', 'ipfs.redirect_domain.value')];
            });
        });
    };
    /**
     * Resolves the ipfs email field from whois configurations
     * @param domain - domain name
     * @throws [[ResolutionError]]
     * @returns A Promise that resolves in an email address configured for this domain whois
     */
    Resolution.prototype.email = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.record(domain, 'whois.email.value')];
            });
        });
    };
    /**
     * @returns the resolver address for a specific domain
     * @param domain - domain to look for
     */
    Resolution.prototype.resolver = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var resolver;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                        return [4 /*yield*/, this.getNamingMethodOrThrow(domain).resolver(domain)];
                    case 1:
                        resolver = _a.sent();
                        if (!resolver) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, resolver];
                }
            });
        });
    };
    /**
     * @param domain - domain name
     * @returns An owner address of the domain
     */
    Resolution.prototype.owner = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        return [4 /*yield*/, method.owner(domain)];
                    case 1: return [2 /*return*/, (_a.sent()) || null];
                }
            });
        });
    };
    /**
     * @param domain - domain name
     * @param recordKey - a name of a record to be resolved
     * @returns A record value promise for a given record name
     */
    Resolution.prototype.record = function (domain, recordKey) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                method = this.getNamingMethodOrThrow(domain);
                return [2 /*return*/, method.record(domain, recordKey)];
            });
        });
    };
    /**
     * @param domain domain name
     * @param keys Array of record keys to be resolved
     * @returns A Promise with key-value mapping of domain records
     */
    Resolution.prototype.records = function (domain, keys) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                method = this.getNamingMethodOrThrow(domain);
                return [2 /*return*/, method.records(domain, keys)];
            });
        });
    };
    /**
     * @param domain domain name
     * @returns A Promise of whether or not the domain belongs to a wallet
     */
    Resolution.prototype.isRegistered = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                method = this.getNamingMethodOrThrow(domain);
                return [2 /*return*/, method.isRegistered(domain)];
            });
        });
    };
    /**
     * @param domain domain name
     * @returns A Promise of whether or not the domain is available
     */
    Resolution.prototype.isAvailable = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                method = this.getNamingMethodOrThrow(domain);
                return [2 /*return*/, method.isAvailable(domain)];
            });
        });
    };
    /**
     * @returns Produces a namehash from supported naming service in hex format with 0x prefix.
     * Corresponds to ERC721 token id in case of Ethereum based naming service like UNS.
     * @param domain domain name to be converted
     * @param options formatting options
     * @throws [[ResolutionError]] with UnsupportedDomain error code if domain extension is unknown
     */
    Resolution.prototype.namehash = function (domain, options) {
        if (options === void 0) { options = publicTypes_1.NamehashOptionsDefault; }
        domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
        return this.formatNamehash(this.getNamingMethodOrThrow(domain).namehash(domain), options);
    };
    /**
     * @returns a namehash of a subdomain with name label
     * @param parent namehash of a parent domain
     * @param label subdomain name
     * @param namingService "UNS" or "ZNS"
     * @param options formatting options
     */
    Resolution.prototype.childhash = function (parent, label, namingService, options) {
        if (options === void 0) { options = publicTypes_1.NamehashOptionsDefault; }
        var service = this.serviceMap[namingService];
        if (!service) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {
                namingService: namingService,
            });
        }
        return this.formatNamehash(service.childhash(parent, label), options);
    };
    Resolution.prototype.formatNamehash = function (hash, options) {
        hash = hash.replace('0x', '');
        if (options.format === 'dec') {
            return new bn_js_1.default(hash, 'hex').toString(10);
        }
        else {
            return options.prefix ? '0x' + hash : hash;
        }
    };
    /**
     * Checks weather the domain name matches the hash
     * @param domain - domain name to check againt
     * @param hash - hash obtained from the blockchain
     */
    Resolution.prototype.isValidHash = function (domain, hash) {
        domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
        return this.namehash(domain) === hash;
    };
    /**
     * Checks if the domain name is valid according to naming service rules
     * for valid domain names.
     * @param domain - domain name to be checked
     */
    Resolution.prototype.isSupportedDomain = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var namingMethod, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                        namingMethod = this.getNamingMethod(domain);
                        if (!namingMethod) return [3 /*break*/, 2];
                        return [4 /*yield*/, namingMethod.isSupportedDomain(domain)];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a = false;
                        _b.label = 3;
                    case 3: return [2 /*return*/, _a];
                }
            });
        });
    };
    /**
     * Returns the name of the service for a domain UNS | ZNS
     * @param domain - domain name to look for
     */
    Resolution.prototype.serviceName = function (domain) {
        domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
        return this.getNamingMethodOrThrow(domain).serviceName();
    };
    /**
     * Returns all record keys of the domain.
     * This method is strongly unrecommended for production use due to lack of support for many ethereum service providers and low performance
     * @param domain - domain name
     */
    Resolution.prototype.allRecords = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                return [2 /*return*/, this.getNamingMethodOrThrow(domain).allRecords(domain)];
            });
        });
    };
    Resolution.prototype.allNonEmptyRecords = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var records, nonEmptyRecords, _i, _a, _b, key, value;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.allRecords(domain)];
                    case 1:
                        records = _c.sent();
                        nonEmptyRecords = {};
                        for (_i = 0, _a = Object.entries(records); _i < _a.length; _i++) {
                            _b = _a[_i], key = _b[0], value = _b[1];
                            if (value) {
                                nonEmptyRecords[key] = value;
                            }
                        }
                        return [2 /*return*/, nonEmptyRecords];
                }
            });
        });
    };
    Resolution.prototype.dns = function (domain, types) {
        return __awaiter(this, void 0, void 0, function () {
            var dnsUtils, method, dnsRecordKeys, blockchainData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dnsUtils = new DnsUtils_1.default();
                        domain = prepareAndValidate_1.prepareAndValidateDomain(domain);
                        method = this.getNamingMethodOrThrow(domain);
                        dnsRecordKeys = this.getDnsRecordKeys(types);
                        return [4 /*yield*/, method.records(domain, dnsRecordKeys)];
                    case 1:
                        blockchainData = _a.sent();
                        return [2 /*return*/, dnsUtils.toList(blockchainData)];
                }
            });
        });
    };
    /**
     * Retrieves the tokenURI from the registry smart contract.
     * @returns the ERC721Metadata#tokenURI contract method result
     * @param domain - domain name
     */
    Resolution.prototype.tokenURI = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var namehash;
            return __generator(this, function (_a) {
                namehash = this.namehash(domain);
                return [2 /*return*/, this.getNamingMethodOrThrow(domain).getTokenUri(namehash)];
            });
        });
    };
    /**
     * Retrieves the data from the endpoint provided by tokenURI from the registry smart contract.
     * @returns the JSON response of the token URI endpoint
     * @param domain - domain name
     */
    Resolution.prototype.tokenURIMetadata = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenUri;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.tokenURI(domain)];
                    case 1:
                        tokenUri = _a.sent();
                        return [2 /*return*/, this.getMetadataFromTokenURI(tokenUri)];
                }
            });
        });
    };
    /**
     * Retrieves address of registry contract used for domain
     * @param domain - domain name
     * @returns Registry contract address
     */
    Resolution.prototype.registryAddress = function (domain) {
        return __awaiter(this, void 0, void 0, function () {
            var method;
            return __generator(this, function (_a) {
                method = this.getNamingMethodOrThrow(domain);
                return [2 /*return*/, method.registryAddress(domain)];
            });
        });
    };
    /**
     * Retrieves the domain name from tokenId by parsing registry smart contract event logs.
     * @throws {ResolutionError} if returned domain name doesn't match the original namhash.
     * @returns the domain name retrieved from token metadata
     * @param hash - domain hash
     * @param service - nameservice which is used for lookup
     */
    Resolution.prototype.unhash = function (hash, service) {
        return __awaiter(this, void 0, void 0, function () {
            var name;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        hash = namehash_1.fromDecStringToHex(hash);
                        return [4 /*yield*/, this.serviceMap[service].getDomainFromTokenId(hash)];
                    case 1:
                        name = _a.sent();
                        if (this.namehash(name) !== hash) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {
                                methodName: 'unhash',
                                domain: name,
                                providerMessage: 'Service provider returned an invalid domain name',
                            });
                        }
                        return [2 /*return*/, name];
                }
            });
        });
    };
    /**
     * Retrieves address of registry contract used for domain
     * @param domains - domain name
     * @returns Promise<Locations> - A map of domain name and Location (a set of attributes like blockchain,
     */
    Resolution.prototype.locations = function (domains) {
        return __awaiter(this, void 0, void 0, function () {
            var method, _i, domains_1, domain;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        method = this.getNamingMethodOrThrow(domains[0]);
                        _i = 0, domains_1 = domains;
                        _a.label = 1;
                    case 1:
                        if (!(_i < domains_1.length)) return [3 /*break*/, 4];
                        domain = domains_1[_i];
                        return [4 /*yield*/, method.isSupportedDomain(domain)];
                    case 2:
                        if (!(_a.sent())) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.InconsistentDomainArray);
                        }
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, method.locations(domains)];
                }
            });
        });
    };
    Resolution.prototype.getMetadataFromTokenURI = function (tokenUri) {
        return __awaiter(this, void 0, void 0, function () {
            var resp, _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, Networking_1.default.fetch(tokenUri, {})];
                    case 1:
                        resp = _d.sent();
                        if (resp.ok) {
                            return [2 /*return*/, resp.json()];
                        }
                        _a = resolutionError_1.default.bind;
                        _b = [void 0, resolutionError_1.ResolutionErrorCode.ServiceProviderError];
                        _c = {};
                        return [4 /*yield*/, resp.text()];
                    case 2: throw new (_a.apply(resolutionError_1.default, _b.concat([(_c.providerMessage = _d.sent(),
                            _c.method = 'UDAPI',
                            _c.methodName = 'tokenURIMetadata',
                            _c)])))();
                }
            });
        });
    };
    Resolution.prototype.getDnsRecordKeys = function (types) {
        var records = ['dns.ttl'];
        types.forEach(function (type) {
            records.push("dns." + type);
            records.push("dns." + type + ".ttl");
        });
        return records;
    };
    Resolution.prototype.getPreferableNewRecord = function (domain, newRecord, oldRecord) {
        return __awaiter(this, void 0, void 0, function () {
            var records;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.records(domain, [newRecord, oldRecord])];
                    case 1:
                        records = _a.sent();
                        if (!records[newRecord] && !records[oldRecord]) {
                            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.RecordNotFound, {
                                recordName: newRecord,
                                domain: domain,
                            });
                        }
                        return [2 /*return*/, records[newRecord] || records[oldRecord]];
                }
            });
        });
    };
    Resolution.prototype.getNamingMethod = function (domain) {
        return this.serviceMap[utils_1.findNamingServiceName(domain)];
    };
    Resolution.prototype.getNamingMethodOrThrow = function (domain) {
        var method = this.getNamingMethod(domain);
        if (!method) {
            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {
                domain: domain,
            });
        }
        return method;
    };
    return Resolution;
}());
exports.Resolution = Resolution;
exports.default = Resolution;
function isApi(obj) {
    return obj && obj.api;
}
