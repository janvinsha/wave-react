{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t(require(\"@uauth/common\"), require(\"@unstoppabledomains/resolution\"), require(\"global\"), require(\"jose\")) : \"function\" == typeof define && define.amd ? define([\"@uauth/common\", \"@unstoppabledomains/resolution\", \"global\", \"jose\"], t) : (e || self).UAuth = t(e.common, e.resolution, e.global, e.jose);\n}(this, function (e, t, r, n) {\n  function o(e) {\n    return e && \"object\" == typeof e && \"default\" in e ? e : {\n      default: e\n    };\n  }\n\n  var i = /*#__PURE__*/o(r);\n\n  function u() {\n    return u = Object.assign || function (e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var r = arguments[t];\n\n        for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n      }\n\n      return e;\n    }, u.apply(this, arguments);\n  }\n\n  function s(e, t) {\n    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, a(e, t);\n  }\n\n  function c(e) {\n    return c = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    }, c(e);\n  }\n\n  function a(e, t) {\n    return a = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    }, a(e, t);\n  }\n\n  function l() {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n\n    try {\n      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }\n\n  function f(e, t, r) {\n    return f = l() ? Reflect.construct : function (e, t, r) {\n      var n = [null];\n      n.push.apply(n, t);\n      var o = new (Function.bind.apply(e, n))();\n      return r && a(o, r.prototype), o;\n    }, f.apply(null, arguments);\n  }\n\n  function h(e) {\n    var t = \"function\" == typeof Map ? new Map() : void 0;\n    return h = function (e) {\n      if (null === e || -1 === Function.toString.call(e).indexOf(\"[native code]\")) return e;\n      if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n\n      if (void 0 !== t) {\n        if (t.has(e)) return t.get(e);\n        t.set(e, r);\n      }\n\n      function r() {\n        return f(e, arguments, c(this).constructor);\n      }\n\n      return r.prototype = Object.create(e.prototype, {\n        constructor: {\n          value: r,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), a(r, e);\n    }, h(e);\n  }\n\n  function d(e, t) {\n    if (null == e) return {};\n    var r,\n        n,\n        o = {},\n        i = Object.keys(e);\n\n    for (n = 0; n < i.length; n++) t.indexOf(r = i[n]) >= 0 || (o[r] = e[r]);\n\n    return o;\n  }\n\n  function p(e, t) {\n    (null == t || t > e.length) && (t = e.length);\n\n    for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];\n\n    return n;\n  }\n\n  function m(e, t) {\n    var r = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n    if (r) return (r = r.call(e)).next.bind(r);\n\n    if (Array.isArray(e) || (r = function (e, t) {\n      if (e) {\n        if (\"string\" == typeof e) return p(e, t);\n        var r = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === r && e.constructor && (r = e.constructor.name), \"Map\" === r || \"Set\" === r ? Array.from(e) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? p(e, t) : void 0;\n      }\n    }(e)) || t && e && \"number\" == typeof e.length) {\n      r && (e = r);\n      var n = 0;\n      return function () {\n        return n >= e.length ? {\n          done: !0\n        } : {\n          done: !1,\n          value: e[n++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function v(e, t) {\n    /*#__PURE__*/\n    return function (r) {\n      function n() {\n        var n;\n        return (n = r.call(this, t) || this).name = e, n;\n      }\n\n      return s(n, r), n;\n    }( /*#__PURE__*/h(Error));\n  }\n\n  var g = v(\"PopupTimeoutError\", \"The popup has timed out.\"),\n      _ = v(\"PopupClosedError\", \"The popup was closed.\"),\n      w = function (e) {\n    return String.fromCharCode.apply(null, Array.from(new Uint8Array(e)));\n  },\n      y = new TextEncoder(),\n      P = function () {\n    return i.default;\n  },\n      b = function (e) {\n    return P().btoa(e);\n  },\n      R = function (e) {\n    return b(e).replace(/=+$/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  },\n      S = function () {\n    var e;\n    return null != (e = P().crypto) ? e : P().msCrypto;\n  },\n      O = function (e) {\n    return S().getRandomValues(new Uint8Array(e));\n  },\n      k = function () {\n    var e;\n    return null != (e = S().subtle) ? e : S().webkitSubtle;\n  },\n      A = function (e) {\n    try {\n      var t = k().digest({\n        name: \"SHA-256\"\n      }, e);\n      return P().msCrypto ? Promise.resolve(new Promise(function (e, r) {\n        t.oncomplete = function (t) {\n          return e(t.target.result);\n        }, t.onerror = function (e) {\n          return r(e.error);\n        }, t.onabort = function () {\n          return r(\"The digest operation was aborted\");\n        };\n      })) : Promise.resolve(t);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n      j = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.\",\n      T = function (e) {\n    return P().atob(e);\n  },\n      I = new TextDecoder();\n\n  function U(e) {\n    return Array.from(new Set(e));\n  }\n\n  var z = function (e) {\n    return U(e.trim().split(/\\s+/)).sort().join(\" \");\n  };\n\n  function L(e) {\n    var t = {};\n    return e.forEach(function (r, n) {\n      t[n] = e.getAll(n).length > 1 ? e.getAll(n) : e.get(n);\n    }), t;\n  }\n\n  function E(e) {\n    var t = new URLSearchParams([].concat(Object.entries(e)).filter(function (e) {\n      return null != e[0] && null != e[1];\n    }));\n    return t.sort(), t.toString();\n  }\n\n  var C = {\n    createCodeChallengeAndVerifier: function (e, t) {\n      void 0 === e && (e = 43), void 0 === t && (t = \"S256\");\n\n      try {\n        var r = function (e) {\n          return Array.from(O(e)).map(function (e) {\n            return j[e % j.length];\n          }).join(\"\");\n        }(e);\n\n        switch (t) {\n          case \"plain\":\n            return Promise.resolve({\n              verifier: r,\n              challenge: r\n            });\n\n          case \"S256\":\n            return Promise.resolve(A(y.encode(r).buffer)).then(function (e) {\n              return {\n                verifier: r,\n                challenge: R(w(e))\n              };\n            });\n\n          default:\n            throw new Error(\"bad challenge method\");\n        }\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    },\n    getCrypto: S,\n    getCryptoSubtle: k,\n    getRandomBytes: O,\n    sha256: A,\n    verifyIdToken: function (e, t, r, o) {\n      try {\n        return Promise.resolve(n.jwtVerify(t, n.createRemoteJWKSet(new URL(e)), {\n          audience: o\n        })).then(function (e) {\n          var n = e.payload;\n          if (n.__raw = t, r !== n.nonce) throw new Error(\"nonces don't match\");\n          return n;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n  },\n      x = {\n    decodeState: function (e) {\n      var t = e.split(\".\"),\n          r = t[1];\n      if (t.slice(2).length > 0) throw new Error(\"failed to decode state\");\n      return (null == r ? void 0 : r.length) > 0 ? JSON.parse(decodeURIComponent(T(r))) : void 0;\n    },\n    encodeState: function (e) {\n      return R(w(O(32))) + \".\" + (null == e ? \"\" : R(encodeURIComponent(JSON.stringify(e))));\n    },\n    fromBase64: T,\n    textDecoder: I,\n    textEncoder: y,\n    toBase64: b,\n    toUrlEncodedBase64: R,\n    stringFromBuffer: w\n  },\n      q = {\n    __proto__: null,\n    crypto: C,\n    encoding: x,\n    getSortedScope: z,\n    getWindow: P,\n    objectFromEntries: function (e) {\n      for (var t, r = {}, n = m(e); !(t = n()).done;) {\n        var o = t.value;\n        r[o[0]] = o[1];\n      }\n\n      return r;\n    },\n    objectFromURLSearchParams: L,\n    objectToKey: E,\n    retry: function e(t, r, n, o, i) {\n      return void 0 === r && (r = 4), void 0 === n && (n = 250), void 0 === o && (o = 2), void 0 === i && (i = null), r <= 0 ? Promise.reject(i) : t().catch(function (i) {\n        try {\n          return Promise.resolve(new Promise(function (e) {\n            return setTimeout(e, n);\n          })).then(function () {\n            return e(t, r - 1, n * o, o, i);\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      });\n    },\n    uniqueElementsFromArray: U\n  },\n      D = /*#__PURE__*/function (e) {\n    function t(t, r, n) {\n      var o;\n      return (o = e.call(this, t + \": \" + r + (n ? \"\\nSee more at \" + n + \".\" : \"\")) || this).code = void 0, o.description = void 0, o.uri = void 0, o.code = t, o.description = r, o.uri = n, o;\n    }\n\n    return s(t, e), t.fromResponse = function (e) {\n      return new t(e.error, e.error_description, e.error_uri);\n    }, t;\n  }( /*#__PURE__*/h(Error)),\n      F = [\"url\"],\n      N = [\"url\", \"client_id\", \"client_secret\", \"client_auth_method\"],\n      W = /*#__PURE__*/function () {\n    function e(e) {\n      this.options = void 0, this.options = e;\n    }\n\n    var t = e.prototype;\n    return t.buildAuthorizeUrl = function (e) {\n      return this._buildUrl(e);\n    }, t.buildLogoutUrl = function (e) {\n      return this._buildUrl(e);\n    }, t.parseAuthorizeResponseFromFragment = function (e) {\n      return this._validateResponse(L(new URLSearchParams(new URL(e).hash.substring(1))));\n    }, t.parseAuthorizeResponseFromQuery = function (e) {\n      return this._validateResponse(L(new URL(e).searchParams));\n    }, t.authorizeWithPopup = function (e, t) {\n      void 0 === t && (t = {});\n\n      try {\n        var r,\n            n = this;\n        if (!window) throw new Error(\"no window in options\");\n        var o = n.buildAuthorizeUrl(e),\n            i = t.popup,\n            u = null != (r = t.timeout) ? r : 36e5;\n        if (i) i.location.href = o;else {\n          var s,\n              c,\n              a = null != (s = t.width) ? s : 600,\n              l = null != (c = t.height) ? c : 800;\n          if (!(i = window.open(o, \"uauth:authorize:popup\", \"left=\" + (window.screenX + (window.innerWidth - a) / 2) + \",top=\" + (window.screenY + (window.innerHeight - l) / 2) + \",width=\" + a + \",height=\" + l + \",resizable,scrollbars=yes,status=1\"))) throw new Error(\"popup failed to be constructed\");\n        }\n        var f = !1;\n        return Promise.resolve(new Promise(function (t, r) {\n          var o = setTimeout(function () {\n            f || (clearInterval(s), i.close(), r(new g()));\n          }, u),\n              s = setInterval(function () {\n            var u, c, a, l;\n            !f && null != (u = i) && u.closed && (clearInterval(s), clearTimeout(o), r(new _()));\n\n            try {\n              c = i.location.href, a = new URL(c), l = new URL(e.redirect_uri);\n            } catch (e) {\n              return;\n            }\n\n            if (a.hash = \"\", a.href === l.href) {\n              f = !0, clearInterval(s), clearTimeout(o), i.close();\n\n              try {\n                t(n.parseAuthorizeResponseFromFragment(c));\n              } catch (e) {\n                r(e);\n              }\n            }\n          }, 10);\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.authorizeWithDevice = function (e) {\n      return Promise.resolve({});\n    }, t.getToken = function (e) {\n      try {\n        var t = this._buildRequest(e, {\n          method: \"POST\"\n        });\n\n        return Promise.resolve(this._fetchJSON(t[0], t[1]));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.introspect = function (e) {\n      var t = this._buildRequest(e, {\n        method: \"POST\"\n      });\n\n      return this._fetchJSON(t[0], t[1]);\n    }, t.revoke = function (e) {\n      try {\n        var t = this._buildRequest(e, {\n          method: \"POST\"\n        });\n\n        return Promise.resolve(this._fetchJSON(t[0], t[1])).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.userinfo = function (e) {\n      var t = this._buildRequest(e, {\n        method: \"GET\",\n        headers: {\n          Authorization: \"Basic \" + e.access_token\n        }\n      });\n\n      return this._fetchJSON(t[0], t[1]);\n    }, t.jwks = function (e) {\n      var t = this._buildRequest(e, {\n        method: \"GET\"\n      });\n\n      return this._fetchJSON(t[0], t[1]);\n    }, t.getTokenWithAuthorizationCode = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithRefreshToken = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithDeviceCode = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithPassword = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithSAML = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithClientCredentials = function (e) {\n      return this.getToken(e);\n    }, t._buildUrl = function (e) {\n      for (var t = e.url, r = d(e, F), n = new URL(t), o = new URLSearchParams(), i = 0, u = Object.entries(r); i < u.length; i++) {\n        var s = u[i],\n            c = s[0],\n            a = s[1];\n        null != c && null != a && o.append(c, a);\n      }\n\n      return n.search = o.toString(), n.toString();\n    }, t._buildRequest = function (e, t) {\n      var r,\n          n = e.url,\n          o = e.client_id,\n          i = e.client_secret,\n          s = e.client_auth_method,\n          c = d(e, N),\n          a = t.headers,\n          l = t.method,\n          f = new Headers(null != (r = this.options.headers) ? r : []);\n      new Headers(null != a ? a : []).forEach(function (e, t) {\n        f.set(t, e);\n      }), \"POST\" === t.method && f.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n      var h = u({\n        client_id: o\n      }, c);\n\n      switch (s) {\n        case \"client_secret_basic\":\n          if (null == i) throw new Error(\"Client secret not present!\");\n          f.set(\"Authorization\", \"Basic \" + b(o + \":\" + i));\n          break;\n\n        case \"client_secret_post\":\n          if (null == i) throw new Error(\"Client secret not present!\");\n          h.client_secret = i;\n          break;\n\n        case \"none\":\n        case void 0:\n        case null:\n          break;\n\n        default:\n          throw new Error(\"Bad client_auth_method\");\n      }\n\n      return [n, {\n        method: l,\n        headers: f,\n        body: \"POST\" === l ? new URLSearchParams(Object.entries(h)) : void 0\n      }];\n    }, t._validateResponse = function (t) {\n      if (t.error) throw e.Error.fromResponse(t);\n      return t;\n    }, t._fetchJSON = function (e, t) {\n      try {\n        var r,\n            n = this;\n\n        if (t.headers) {\n          var o = new Headers(t.headers);\n          o.set(\"Accept\", \"application/json\"), t.headers = o;\n        } else t.headers = {\n          Accept: \"application/json\"\n        };\n\n        return Promise.resolve(null == (r = window) ? void 0 : r.fetch(e, t)).then(function (e) {\n          return Promise.resolve(e.json()).then(function (t) {\n            if (n._validateResponse(t), !e.ok) throw new Error(e.status + \" \" + e.statusText + \": \" + JSON.stringify(t));\n            return t;\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, e;\n  }();\n\n  W.Error = D;\n\n  var B = /*#__PURE__*/function () {\n    function e(e) {\n      this.client = void 0, this.client = e;\n    }\n\n    var t = e.prototype;\n    return t.get = function (e, t) {\n      var r = void 0 === t ? {} : t,\n          n = r.mustExist,\n          o = void 0 !== n && n,\n          i = r.deleteAfter,\n          u = void 0 !== i && i;\n\n      try {\n        var s = this;\n        return Promise.resolve(s.client.getStore().get(e)).then(function (t) {\n          var r;\n\n          function n(t) {\n            if (r) return t;\n\n            var n = function () {\n              if (u) return Promise.resolve(s.client.getStore().delete(e)).then(function () {});\n            }();\n\n            return n && n.then ? n.then(function () {\n              return i;\n            }) : i;\n          }\n\n          if (null != t) {\n            var i = t.value,\n                c = t.expiresAt,\n                a = function () {\n              if (0 !== c && c < Date.now()) return Promise.resolve(s.client.getStore().delete(e)).then(function () {\n                if (o) throw new Error(e + \" does not exist in store\");\n                r = 1;\n              });\n            }();\n\n            return a && a.then ? a.then(n) : n(a);\n          }\n\n          if (o) throw new Error(e + \" does not exist in store\");\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.set = function (e, t, r) {\n      void 0 === r && (r = 0);\n\n      try {\n        return Promise.resolve(this.client.getStore().set(e, {\n          expiresAt: 0 === r ? 0 : Date.now() + r,\n          value: t\n        })).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.setAuthorizeRequest = function (e) {\n      try {\n        return Promise.resolve(this.set(\"request\", e, 3e5)).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getAuthorizeRequest = function () {\n      return this.get(\"request\", {\n        mustExist: !0,\n        deleteAfter: !0\n      });\n    }, t.setLogoutRequest = function (e) {\n      try {\n        return Promise.resolve(this.set(\"logout-request\", e, 3e5)).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getLogoutRequest = function () {\n      return this.get(\"logout-request\", {\n        mustExist: !0,\n        deleteAfter: !0\n      });\n    }, t.setVerifier = function (e, t) {\n      try {\n        return Promise.resolve(this.set(\"verifier:\" + e, t, 3e5)).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getVerifier = function (e) {\n      return this.get(\"verifier:\" + e, {\n        mustExist: !0,\n        deleteAfter: !0\n      });\n    }, t.setOpenIdConfiguration = function (e, t, r) {\n      try {\n        return Promise.resolve(this.set(\"openidConfiguration:\" + e, t, r)).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getOpenIdConfiguration = function (e) {\n      return this.get(\"openidConfiguration:\" + e);\n    }, t.setAuthorization = function (e) {\n      try {\n        var t = this,\n            r = {\n          clientID: e.idToken.aud,\n          resource: e.resource,\n          scope: e.scope,\n          username: e.idToken.sub\n        },\n            n = e.expiresAt - Date.now();\n        return Promise.resolve(t.set(\"username\", r.username, n)).then(function () {\n          var o = t.set;\n          return Promise.resolve(t._getAuthorizationKey(r)).then(function (r) {\n            return Promise.resolve(o.call(t, r, e, n)).then(function () {});\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.deleteAuthorization = function (e) {\n      try {\n        var t = this;\n        return Promise.resolve(t.get(\"username\")).then(function (r) {\n          return Promise.resolve(t._getUsername(e.username, r)).then(function (n) {\n            function o() {\n              var r = t.client.getStore(),\n                  n = r.delete;\n              return Promise.resolve(t._getAuthorizationKey(e)).then(function (e) {\n                return n.call(r, e);\n              });\n            }\n\n            e.username = n;\n\n            var i = function () {\n              if (e.username === r) return Promise.resolve(t.client.getStore().delete(\"username\")).then(function () {});\n            }();\n\n            return i && i.then ? i.then(o) : o();\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getAuthorization = function (e) {\n      try {\n        var t = this,\n            r = t.get;\n        return Promise.resolve(t._getAuthorizationKey(e)).then(function (e) {\n          return r.call(t, e, {\n            mustExist: !0\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t._getAuthorizationKey = function (e) {\n      try {\n        var t = this,\n            r = E,\n            n = t._getUsername,\n            o = e.username;\n        return Promise.resolve(t.get(\"username\")).then(function (i) {\n          return Promise.resolve(n.call(t, o, i)).then(function (n) {\n            var o, i, u;\n            return \"authorization?\" + r.call(q, {\n              username: n,\n              clientID: null != (o = e.clientID) ? o : t.client.fallbackLoginOptions.clientID,\n              scope: z(null != (i = e.scope) ? i : t.client.fallbackLoginOptions.scope),\n              resource: null != (u = e.resource) ? u : t.client.fallbackLoginOptions.resource\n            });\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t._getUsername = function (e, t) {\n      try {\n        if (null == e && null == t) throw new Error(\"no username given\");\n        return Promise.resolve(null != e ? e : t);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, e;\n  }(),\n      M = /*#__PURE__*/function () {\n    function e(e) {\n      this.storage = void 0, this.storage = e;\n    }\n\n    var t = e.prototype;\n    return t.get = function (e) {\n      var t = this.storage.getItem(e);\n      return null != t ? JSON.parse(t) : null;\n    }, t.delete = function (e) {\n      return this.storage.removeItem(e), !0;\n    }, t.set = function (e, t) {\n      return this.storage.setItem(e, JSON.stringify(t)), this;\n    }, e;\n  }(),\n      J = \"2.2.0\",\n      V = [\"clientID\", \"username\", \"scope\", \"resource\"];\n\n  if (\"undefined\" != typeof window) {\n    var H = window;\n    H.UAUTH_VERSION = H.UAUTH_VERSION || {}, H.UAUTH_VERSION.JS = J;\n  }\n\n  var K = /*#__PURE__*/function () {\n    var r = n.prototype;\n\n    function n(r) {\n      var n, o, i, s, c, a, l, f, h, d;\n      this.util = q, this._clientStore = new B(this), this.api = void 0, this.fallbackIssuer = void 0, this.fallbackLoginOptions = void 0, this.fallbackLogoutOptions = void 0, this.cacheOptions = void 0, this.issuerResolver = void 0, this.resolution = void 0, this.store = void 0, this.storeOptions = void 0, this.fallbackIssuer = null != (n = r.fallbackIssuer) ? n : \"https://auth.unstoppabledomains.com\", this.resolution = null != (o = r.resolution) ? o : new t.Resolution(), this.storeOptions = {\n        store: r.store,\n        storeType: null != (i = r.storeType) ? i : \"localstore\"\n      }, this.cacheOptions = u({\n        issuer: !1,\n        userinfo: !0\n      }, null != (s = r.cacheOptions) ? s : {}), this.api = new W({\n        headers: {}\n      }), this.fallbackLoginOptions = {\n        clientID: r.clientID,\n        clientSecret: r.clientSecret,\n        clientAuthMethod: null != (c = r.clientAuthMethod) ? c : r.clientSecret ? \"client_secret_post\" : \"none\",\n        maxAge: null != (a = r.maxAge) ? a : 3e5,\n        prompt: null != (l = r.prompt) ? l : \"login\",\n        resource: r.resource,\n        redirectUri: r.redirectUri,\n        responseMode: null != (f = r.responseMode) ? f : \"fragment\",\n        scope: null != (h = r.scope) ? h : \"openid wallet\"\n      }, this.fallbackLogoutOptions = {\n        rpInitiatedLogout: null != (d = r.rpInitiatedLogout) ? d : \"string\" == typeof r.postLogoutRedirectUri,\n        postLogoutRedirectUri: r.postLogoutRedirectUri\n      };\n      var p = this;\n      this.issuerResolver = new e.DefaultIssuerResolver({\n        webfingerResolver: new e.DefaultWebFingerResolver({\n          ipfsResolver: new e.DefaultIPFSResolver(function () {\n            return (r.createIpfsUrl || e.DefaultIPFSResolver.defaultCreateUrl).apply(void 0, [].slice.call(arguments));\n          }),\n          domainResolver: {\n            records: function (e, r) {\n              try {\n                return Promise.resolve(function (t, n) {\n                  try {\n                    var o = Promise.resolve(p.resolution.records(e, r));\n                  } catch (e) {\n                    return n(e);\n                  }\n\n                  return o && o.then ? o.then(void 0, n) : o;\n                }(0, function (e) {\n                  if (e instanceof t.ResolutionError && e.code === t.ResolutionErrorCode.UnspecifiedResolver) return {};\n                  throw e;\n                }));\n              } catch (e) {\n                return Promise.reject(e);\n              }\n            }\n          }\n        })\n      });\n    }\n\n    return r.getStore = function () {\n      if (this.store) return this.store;\n      if (this.storeOptions.store) this.store = this.storeOptions.store;else switch (this.storeOptions.storeType) {\n        case \"localstore\":\n          this.store = new M(window.localStorage);\n          break;\n\n        case \"sessionstore\":\n          this.store = new M(window.sessionStorage);\n          break;\n\n        case \"memory\":\n          this.store = new Map();\n          break;\n\n        default:\n          throw new Error(\"Bad storeType provided\");\n      }\n      return this.store;\n    }, r.buildAuthorizeRequest = function (e) {\n      try {\n        var t = this,\n            r = u({}, t.fallbackLoginOptions, e),\n            n = e.username;\n        return Promise.resolve(t.getOpenIdConfiguration(n)).then(function (e) {\n          return Promise.resolve(C.createCodeChallengeAndVerifier(43, \"S256\")).then(function (o) {\n            var i,\n                u = o.verifier,\n                s = o.challenge,\n                c = x.toBase64(x.stringFromBuffer(C.getRandomBytes(32))),\n                a = x.encodeState(r.state),\n                l = {\n              url: e.authorization_endpoint,\n              code_challenge: s,\n              nonce: c,\n              state: a,\n              flow_id: null != (i = r.flowId) ? i : \"login\",\n              login_hint: n,\n              client_id: r.clientID,\n              client_secret: r.clientSecret,\n              client_auth_method: r.clientAuthMethod,\n              max_age: r.maxAge,\n              prompt: r.prompt,\n              resource: r.resource,\n              redirect_uri: r.redirectUri,\n              response_mode: r.responseMode,\n              scope: r.scope,\n              code_challenge_method: \"S256\",\n              response_type: \"code\",\n              package_name: (null == r ? void 0 : r.packageName) || \"@uauth/js\",\n              package_version: (null == r ? void 0 : r.packageVersion) || J\n            };\n            return Promise.resolve(t._clientStore.setAuthorizeRequest(l)).then(function () {\n              return Promise.resolve(t._clientStore.setVerifier(s, u)).then(function () {\n                return l;\n              });\n            });\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.loginWithPopup = function (e, t) {\n      void 0 === e && (e = {});\n\n      try {\n        var r = this;\n        return e.responseMode = \"fragment\", Promise.resolve(r.buildAuthorizeRequest(e)).then(function (e) {\n          return Promise.resolve(r.api.authorizeWithPopup(e, t)).then(function (t) {\n            return Promise.resolve(r.verifyAuthorizeResponse(e, t));\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.login = function (e) {\n      void 0 === e && (e = {});\n\n      try {\n        var t = this;\n        return Promise.resolve(t.buildAuthorizeRequest(e)).then(function (r) {\n          function n() {\n            window.location.href = o;\n          }\n\n          var o = t.api.buildAuthorizeUrl(r),\n              i = function () {\n            if (\"function\" == typeof e.beforeRedirect) return Promise.resolve(e.beforeRedirect(o)).then(function () {});\n          }();\n\n          return i && i.then ? i.then(n) : n();\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.loginCallback = function (e) {\n      try {\n        var t,\n            r = this,\n            n = null != (t = null == e ? void 0 : e.url) ? t : window.location.href;\n        return Promise.resolve(r._clientStore.getAuthorizeRequest()).then(function (e) {\n          var t;\n          if (\"fragment\" === e.response_mode) t = r.api.parseAuthorizeResponseFromFragment(n);else {\n            if (\"query\" !== e.response_mode) throw new Error(\"Unsupported response_mode\");\n            t = r.api.parseAuthorizeResponseFromQuery(n);\n          }\n          return Promise.resolve(r.verifyAuthorizeResponse(e, t)).then(function (t) {\n            return {\n              authorization: t,\n              state: x.decodeState(e.state)\n            };\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.verifyAuthorizeResponse = function (e, t) {\n      try {\n        var r = this;\n        if (e.state !== t.state) throw new Error(\"states don't match\");\n        return Promise.resolve(r.getOpenIdConfiguration(e.login_hint)).then(function (n) {\n          var o = t.code,\n              i = e.client_auth_method,\n              u = e.client_secret,\n              s = e.client_id,\n              c = n.token_endpoint;\n          return Promise.resolve(r._clientStore.getVerifier(e.code_challenge)).then(function (t) {\n            return Promise.resolve(r.api.getTokenWithAuthorizationCode({\n              url: c,\n              client_id: s,\n              client_secret: u,\n              client_auth_method: i,\n              grant_type: \"authorization_code\",\n              code: o,\n              code_verifier: t,\n              redirect_uri: e.redirect_uri\n            })).then(function (t) {\n              return Promise.resolve(C.verifyIdToken(n.jwks_uri, t.id_token, e.nonce, e.client_id)).then(function (n) {\n                var o = {\n                  accessToken: t.access_token,\n                  expiresAt: Date.now() + 1e3 * t.expires_in,\n                  idToken: n,\n                  scope: z(e.scope),\n                  resource: e.resource\n                };\n                return Promise.resolve(r._clientStore.setAuthorization(o)).then(function () {\n                  return o;\n                });\n              });\n            });\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.getOpenIdConfiguration = function (e) {\n      try {\n        var t,\n            r = function (r) {\n          return t ? r : Promise.resolve(e ? n.issuerResolver.resolve(e, n.fallbackIssuer) : fetch(n.fallbackIssuer + \"/.well-known/openid-configuration\").then(function (e) {\n            return e.ok ? e.json() : Promise.reject(new Error(\"bad openid-configuration response\"));\n          })).then(function (t) {\n            return Promise.resolve(n._clientStore.setOpenIdConfiguration(null != e ? e : \"\", t, \"number\" == typeof n.cacheOptions.issuer ? n.cacheOptions.issuer : 36e5)).then(function () {\n              return t;\n            });\n          });\n        },\n            n = this,\n            o = function () {\n          if (n.cacheOptions.issuer) return Promise.resolve(n._clientStore.getOpenIdConfiguration(null != e ? e : \"\")).then(function (e) {\n            if (e) return t = 1, e;\n          });\n        }();\n\n        return Promise.resolve(o && o.then ? o.then(r) : r(o));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.authorization = function (e) {\n      void 0 === e && (e = {});\n\n      try {\n        return Promise.resolve(this._clientStore.getAuthorization(e));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.user = function (e) {\n      void 0 === e && (e = {});\n\n      try {\n        var t,\n            r = this,\n            n = null != (t = e.claims) ? t : [\"name\", \"given_name\", \"family_name\", \"middle_name\", \"nickname\", \"preferred_username\", \"profile\", \"picture\", \"website\", \"email\", \"email_verified\", \"gender\", \"birthdate\", \"zoneinfo\", \"locale\", \"phone_number\", \"phone_number_verified\", \"address\", \"updated_at\", \"wallet_address\", \"wallet_type_hint\", \"eip4361_message\", \"eip4361_signature\", \"humanity_check_id\"];\n        return Promise.resolve(r.authorization(e)).then(function (e) {\n          var t = {\n            sub: e.idToken.sub\n          };\n\n          if (r.cacheOptions.userinfo) {\n            for (var o, i = m(n); !(o = i()).done;) {\n              var u = o.value;\n              e.idToken[u] && (t[u] = e.idToken[u]);\n            }\n\n            return t;\n          }\n\n          return Promise.resolve(r.getOpenIdConfiguration(e.idToken.sub)).then(function (o) {\n            return Promise.resolve(r.api.userinfo({\n              client_id: r.fallbackLoginOptions.clientID,\n              client_secret: r.fallbackLoginOptions.clientSecret,\n              client_auth_method: r.fallbackLoginOptions.clientAuthMethod,\n              access_token: e.accessToken,\n              url: o.userinfo_endpoint\n            })).then(function (e) {\n              for (var r, o = m(n); !(r = o()).done;) {\n                var i = r.value;\n                e[i] && (t[i] = e[i]);\n              }\n\n              return t;\n            });\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.buildLogoutRequest = function (e) {\n      try {\n        var t = this;\n        return Promise.resolve(t.authorization(e)).then(function (r) {\n          return Promise.resolve(t.getOpenIdConfiguration(r.idToken.sub)).then(function (n) {\n            var o;\n            if (null == n.end_session_endpoint) throw new Error(\"end_session_endpoint must exist\");\n            var i = null != (o = e.postLogoutRedirectUri) ? o : t.fallbackLogoutOptions.postLogoutRedirectUri;\n            if (null == i) throw new Error(\"postLogoutRedirectUri must be supplied\");\n            var u = {\n              client_id: t.fallbackLoginOptions.clientID,\n              client_secret: t.fallbackLoginOptions.clientSecret,\n              client_auth_method: t.fallbackLoginOptions.clientAuthMethod,\n              url: n.end_session_endpoint,\n              id_token_hint: r.idToken.__raw,\n              post_logout_redirect_uri: i,\n              state: x.encodeState(e.state)\n            };\n            return Promise.resolve(t._clientStore.setLogoutRequest(u)).then(function () {\n              return u;\n            });\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.logout = function (e) {\n      var t = void 0 === e ? {} : e,\n          r = t.clientID,\n          n = t.username,\n          o = t.scope,\n          i = t.resource,\n          s = d(t, V);\n\n      try {\n        var c,\n            a = function (e) {\n          return c ? e : Promise.resolve(l.buildLogoutRequest(f)).then(function (e) {\n            function t() {\n              return Promise.resolve(l._clientStore.deleteAuthorization(h)).then(function () {\n                window.location.href = r;\n              });\n            }\n\n            var r = l.api.buildLogoutUrl(e),\n                n = function () {\n              if (\"function\" == typeof f.beforeRedirect) return Promise.resolve(f.beforeRedirect(r)).then(function () {});\n            }();\n\n            return n && n.then ? n.then(t) : t();\n          });\n        },\n            l = this,\n            f = u({}, l.fallbackLogoutOptions, s),\n            h = {\n          clientID: r,\n          username: n,\n          scope: o,\n          resource: i\n        },\n            p = function () {\n          if (!f.rpInitiatedLogout) return Promise.resolve(l._clientStore.deleteAuthorization(h)).then(function () {\n            c = 1;\n          });\n        }();\n\n        return Promise.resolve(p && p.then ? p.then(a) : a(p));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.logoutCallback = function (e) {\n      void 0 === e && (e = {});\n\n      try {\n        var t,\n            r,\n            n = this,\n            o = null != (t = null == (r = e) ? void 0 : r.url) ? t : window.location.href;\n        return Promise.resolve(n._clientStore.getLogoutRequest()).then(function (e) {\n          var t = n.api.parseAuthorizeResponseFromQuery(o);\n          return Promise.resolve(n.verifyLogoutResponse(e, t)).then(function () {\n            return x.decodeState(e.state);\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, r.verifyLogoutResponse = function (e, t) {\n      try {\n        if (e.state !== t.state) throw new Error(\"states don't match\");\n        return Promise.resolve();\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, n;\n  }();\n\n  return K;\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBAAcA;MAAA,SAAoCC,CAApC,GAAoCA;QAAAA;QAAAA,OAChD,YAEE,IAFF,EAEEC,CAFF,KAEE,IAFF,EAEEC,IAFF,GAEEC,CAFF,EAEEA,CAH8CH;MAG9CG;;MAAAA,OAECC,KADCC,CACD,GADOL,CADRG;IACQH,gBADRM;EADOJ;;EAAAA,IADTK,2BAEE,0BAFF,CACSL;EAAAA,ICCTM,0BACA,uBADA,CDDSN;EAAAA,ICMTO;IAAA,OACAC,0BCTuB,IDSvB,ECTuBC,KAACC,CAADC,SACvBH,UADuB,CAChBI,CADgB,EDSvB,CADA;ECPOA,CFCEZ;EAAAA,IEDFY,CAAaC,oBFCXb;EAAAA,IED6BW,gBAASG;IAAAA,OAAWJ,SAAXI;ECD7B,CHETd;EAAAA,IGFSe,CAAIC,gBCElBC;IAAAA,OAA8CC,WAA9CD;EAAoDE,CJA/CnB;EAAAA,IIA+CmB,cCApDC,CDAoDD,ECAzC;IAAA,OAACE,KAAgBJ,OAAhBI,CAAgBJ,MAAhBI,EAAiCA,EAAjCA,ECAZC,ODAYD,CCAS,KDATA,ECChB,GDDgBA,ECChBE,ODDgBF,CCEbE,KDFaF,ECEL,GDFKA,CAAD;ECEJ,CNFFrB;EAAAA,IMEEwB,CAAQ,eAChBD;IAAQ;IAAO,OACfA,SAAQE,QAAOC,MAAfH,ICHaE,CDGbF,GCHaL,YDEE;ECFF,CPDPlB;EAAAA,IOCO2B;IAAA,OACHD,oBAA+BE,ICFxCC,UDEwCD,CCFtBE,CDEsBF,CAA/BF,CADG;ECDK,CRAZ1B;EAAAA,IQAY+B,gBACTC;IAAAA;IAAAA,OAAgB,SAAIlB,QAAWgB,MAAf,ICANL,CDAM,GCAND,gBDAVQ;ECAU,CTDbhC;EAAAA,ISCaiC,iBACtBC;IAAAA,IAAYC;MAAAA,QADUC,IACCF,MADDE,CACqBC;QAAAA;MAAAA,CADrBD,ECAZX,CDAYW,CACVD;MCDQzB,OACpBQ,IAAMoB,QAAN,GAAwCC,OAAQvC,QAARuC,CAAc,YAGtD,UAAyBX,CAAzB,EAAyBA,CAAzB,EAAyBA;QAAAA,EAChBY,UADgBZ,GAChBa,UAAID,CAAJC,EAAID;UAAAA,OAAQf,WAAMiB,MAAN,CAARF;QACAG,CAFYf,EAEZe,YAAa,UAAYC,CAAZ,EAAYA;UAAAA,OAAMC,UAAND;QAAaE,CAF1BlB,EAE0BkB,YACtCC,YAAU;UAAA,OAAmBL,qCAAnB;QACMA,CAJJd;MAIIc,CAPyB,CAAdH,CAAxC,GAO6BG,OAAI,QAAJA,CAAI3C,CAAJ2C,CARThC;IAQa,CDPjCwB,CCOiC;MAAA,sBAIpBI,CAJoB;IAIpBA;EAAAA,CVbJtC;EAAAA,IUaIsC,wEVbJtC;EAAAA,IWMTgD;IAAA;EAAA,CXNShD;EAAAA,IWMTiD,qBXNSjD;;EYAQ,SAAyBiB,CAAzB,CAAyBA,CAAzB,EAAyBA;IAAAA,OAAYiC,KCFlDC,KDEkDD,CCFhCE,UDEgCF,CAAZjC;ECFpBmC;;EAAAA,kBCCtB3B,CDDsB2B,ECCtB;IAAA,OAAO3C,EAAME,SAAS0C,KAAT1C,CAAa2C,KAAb3C,CAANF,ECCc8C,IDDd9C,GCCc+C,IDDd/C,CCEPgD,GDFOhD,CAAP;ECEAgD,CFHsBL;;EEGtBK,SAA8BC,CAA9BD,CAA8BC,CAA9BD,EAAqCE;IAAAA,IAAM5D,MAAN4D;IAAM,OAAQJ,UAAY,UCHzCK,CDGyC,ECHzCA,CDGyC,ECHzCA;MAAAA,CACtBC,GADsBD,GAGtBnC,SAUAqC,CAVA,EAUAhC,MAVA,GAEOiC,CAFP,GAEOA,SAAQD,CAARC,CAFP,GAEetC,CAACnB,IAAD,CAEX0D,CAFW,CALOJ;IAOdK,CDJ2CV,GCG7CM,CDHqC;ECG9BK;;EAAAA,SAAOD,CAAPC,CAAYpC,CAAZoC,EAAYpC;IAAAA,IAAS/B,CACnB8D,OAAOK,eAAPL,CAEWI,GAInBD,MAJmBC,CCTJE,MAAYC,QAAZ,CACP3C,CADO,CDSIwC,ECRPI,MDQOJ,CCRPI,UACjB5C,CADiB4C,EACbF;MAAAA,eAAOG,IAAPH,IAAOG,QAAiBC,IAAxBJ;IAAwBI,CDOJN,CAFXJ,CADU/B;ICJY,mBAAiB0C,QAAjB;EAAA;;EAAA,IAA8BC;IAA9BC,8BAGvBF,YCUhB/C,CDVgB+C,ECUV9C,CDVU8C,ECWdG;MAAAA,2CPAkC5E,UOAlC4E;;MPEAC;QAAAA,kBADSnD,CACTmD,EADS;UAAA,OACTA,WAA8BjD,IAA9BiD,EAFkCC,GAElCD,CAEA,UAVyBnD,CAUzB,EAVyB;YAAA,OACzBqD,MAAOrE,QAAP,CADyB;UACZE,CAObiE,EAPkB/C,IAOlB+C,CANGC,EAMHD,CADS;QALF,CAMPA,CANOnD,CAMPmD;;QANO;UAAAG;YAA2BjD,cAC1B,QAD0BA,CAUlC;cAAAkD,QACE,GADF;cACEC,SACE;YAFJ,CAVkCnD;;UAY9B;YAAAW,OAAOD,OAACwC,QAAD,CAAWC,WACpBpF,CADoBoF,EACfC,MADeD,CAAX,EACTE,IADS,CACT3C;cAAAC,OAIoC2C;gBAAAA,QAAmBJ,GAAnBI;gBAA6BF,SAJjEC;cAIoCC,CAJpC3C;YAAA,CADS,CAAPA;;UACF;YACE,MACEuC,UACAC,sBADAD,CADF;QAdG;MAoBL,CAdFJ,CAcE,OACEnD,CADF,EACE;QAAA,OAAU4D,OAAM,OAANA,CAAM5D,CAAN4D,CAAV;MAAgB;IAAA,CM/B+C;IN+B/CnD,SAjBc,GMdiC;INcjCoD,kBMdiC;INcjCzD,cOClCK,GDfmE;ICenEA,SDfmE;ICgBnEoD,yBACAzD,CADAyD,EACAzD,CADAyD,EACAzD,CADAyD,EACAzD,CADAyD,EACAzD;MAAAA,IACA0D;QAAAA,cACAC,QADAD,CCjBIC,YAGJC,CAHID,EAIJE,qBACElD,UADFkD,CAJIF,EAM6BG;UAAAA,QAC/BC;QAD+BD,CAN7BH,CDiBJD,ECTEM,IDSFN,CCTEM;UAAmB,IAAIC,MAAIC,OAAR;UAClBC,cAHIC,CAGJD,EAHIC,aAGJD,EAHIC;UAUeR,OACpB3B,CADoB2B;QACpB,CDAFF;MCAE,CDDF1D,CCCE,OAAUwD,CAAV,EAAUA;QAAAA,OAAM7C,iBAAN6C;MAGZ;IAAA;EFrBmE,CAA9B;EAAA,IEqBrCa;IAAOC,WApBU;MAAA;MAAA,IDqBFtG,CACfuG,OCtBiB;MDsBjBA,YEvBkB,CFuBlBA,EEvBkBtE,MFuBlBsE,GEtBA,CFsBAA,EEtBAC,MAA0B1C,IAAM0B,KAAN1B,CAA1B0C,wBAA0B1C,CAA1B0C;MAEe,OACb,SAAUhB,CAAV,GAAUA,KAAM,CAAhB,GAAgBxF,QAAhB,IAAgB,CAAhB,GAAgByG,WAGlBC,kBAAOxB,MAHW,CAAhB,GAGQjD,KAAS,CAJJ;IAKXwE,CDaJ;ICbIA,WAAWC;MAAAA,OAA6CxB,cACxDyB,GADwDzB,IFgB5D0B,YGtBkB,EHsBlBA,GGtBkBC,oBACqB7E,KAAe,UAAfA,CAC5BJ,CAD4BI,EADrB,CDM0CkD,CAA7CwB;ICHT,CFgBN;IEhBMI,UAEeC,GFcrB;IEdqBA,WAAmBN,GFcxC;IEd6CO,WAAUC,GFcvD;IEduDA,QHkBvDH,GCJA;IDIAA,kBACAxD,EACAiC,CCNA;IDMAA,gBACAhE;ECPA,CFrBqC;EAAA,IC4BrCA;IACAE,eADAF;IACAE,MACAyF,GAFA3F;IAEA2F,WAFA3F;IAEA2F,iBAFA3F;IAEA2F,YAFA3F;IAEA2F;MAAAA,gDIhCsBC;QAAAA,IACtB1C,IAGAvE,OAJsBiH;QAIQC,EADxB7C,EAAiC,CAAjCA,CACwB6C,IAAT3C,IAAS2C;MAAT3C;;MAAAA,OAAS4C,CAAT5C;IAAS4C,CJ0B9B9F;II1B8B+F,4BJ0B9B/F;II1B8BgG,WAG9B,GJuBAhG;IIvBOgD;MAAAA,4BCPT,CDOSA,GCPT,WACEiD,CADF,KAGEC,CACAC,MAJF,CDOSnD,ECAP,iBALAoD,KAKA,CDAOpD,ECLPoD,KAAU,CAAVA,KAAUC,CAAVD,KAGUC,IAFVH,IADAE,CDKOpD,ECJGvE,wBACD4H,CADC,IACD1H,UACT2H,UAAMD,CAANC,EAEIF;QAAAA,IAAW;UACNhF,cAAQmF,CAAOD,OAAflF,CAGA,sBACDf,CADC,EACD;YAAA;UAAA,CADC,CAHAe,EAIGA,IAJHA,CAIGA,YAAQ3C;YAAAA,SAAK+H,CAAL/H,EAAK+H,KAAL/H,EAAK+H,KAAL/H,EAAK+H,CAAL/H,EAAgBA,CAAhBA;UAAmByH,CAJ9B9E;QAI8B8E,CALnCE,CAKmCF;UAAAA,cACrC,OADqCA,CACV7F,CADU6F;QACPA;MAAUC,CATjC,CDGFnD;ICM2CmD,CLiBlDnG;IKjBkDmG,uBAEnD/E;ELeCpB,CD5BqC;EAAA,IMatCoB;IAAAf,oBCboBoG;MAAAA;MAAAA,yBACnB9H,gBACS+H,IACAC,mBACYjE,CADZiE,GAGP5H,GAJO2H,GAIEA,EALX,CADmBD,KAMRC,IANQD,EAMCE,IANDF,GAMCE,KAAiB,CANlBF,EAMkBG,gBAAoBC,KAApB,CANlBJ,EAM+CG,QAAhE5H,KAJO0H,CAFUD,EAEVC,UAFUD,EAEVC,gBACAC,CAHUF,EAGVE,QACY5H,CAJF0H,EAIVI,CAJUJ;IAIVI;;IAAAA,OAAY/H,EAFZC,CAEY,EAFR2H,CAEQ,GAFRA,EAAJA,YAAIA,GACOC,UACRE,CADQF,EACXE;MAAAA,OAJ2B5C,eAS7B6C,mBAT6B7C,EAShB8C,WATgB9C,CAI3B4C;IAMIJ,CANQ,EAMRA,CANJI;EAOLE,CDEL1G,ECFK0G,aACSC,QDCd3G,CNbsC;EAAA,IOYxB2G,WPZwB;EAAA,IOaxBC,YAbuBhD,WAavBgD,EAbuBhD,eAavBgD,ECff,oBDeeA,CPbwB;EAAA,IQFvCC;IAAA;MAAA,KA8BqBC,OA9BrB,GA8BqBA,MA9BrB,EAiCE,gBAjCF;IAiCE;;IAAA,QAAmBC,WAAnB;IAAmBA,SAAmBC,iBAAnBD,aAEnBC,CAFmBD,EAEnBC;MAAAA;IAAAA,CAFmBD,EAEnBC,mBAAkBC,UACTtI,CADSsI,EACTtI;MAAAA,OAAKuI,KAAUD,SAAVC,CAGdC,CAHcD,CAALvI;IAGTwI,CANmBJ,EAMnBI,uCACcD,UAGdE,CAHcF,EAGdE;MAAAA,oDACcC,0BAER,CAFQA,CADd;IAGUzE,CAbSmE,EAaTnE,oCAAkC0E,UAAUtH,CAAVsH,EAAU;MAKtDC,2CAAgCC,YAAhCD;IACcF,CAnBKN,EAmBLM,uBACoBhD,UAASoD,CAATpD,EAASoD,CAATpD,EAASoD;MAAAA,iBAIrCC,MAJqCD;;MAIrCC;QAAAA;QAAAA,KACJT,OADIS;QACJT,aACAU,gBAAsB,sBAAtBA;QAEKjI,IACH6G,wBAAgBvG,CAAhB,CADGN;QAAAA,IACasG,WADbtG;QAAAA,IACakI,aAGZJ,IAAMK,EAAKb,OAHC,IAGDA,CAHC,GAGDA,IAJZtH;QAIYsH,IAAkBC,CAAlBD,EAEbc,EAAmCH,QAAnCG,CACEjC,IADFiC,GACsCvB,CADtCuB,CAFad,KAGOW;UAAO9B;UAAAA;UAAAA,KAAWkC,YAE1CtJ,IAAKqJ,EAgBHA,KAlBwCC,IAkBlCC,CAlBkCD,GAkBlCC,GAlBuBnC;UAAAA,IAkBdoC,aAhBLC,CACV,WAeeD,IAfJC,CAeID,GAfJ,GAHkBpC;UAGlBsC,IAAGR,EAAOS,UAAS,KAATA,CACT7B,CADS6B,EACT,uBADSA,EAWrB,WARQ1I,MAAO2I,QAAP3I,GAEN,2BAMF,IANE,OAMF,IALUA,MAAO4I,QAAP5I,GAAkBA,OAAO6I,YAAP7I,GACxBA,CADwBA,IACxBA,CAIJ,IAJIA,SAIJ,GAJW8I,CAIX,GAJWA,UAIX,GAJsB9I,CAItB,GAJsBA,oCAPD0I,CAAPT,CAAHQ,EAGH,MAAR,2CAAQ;QASN;QAAA,IAAUvE,MAAV;QAAUA,OAAM7C,4BAMpB,UA9BwBzC,CA8BxB,EA9BwBF,CA8BxB,EA9BwB;UAAA,+BA+BsB2C;YAAAA,MAAQ0H,aACpD,GADoD,EAC9CC,CAAYvC,MAAZuC,EAD8C,EAClCvC,EAAW,OAAXA,CAD0BpF;UACf,CAhCP,EAgCO6G,CAhCP;UAAA,IAiCfe,eACHF,aACOG;YAAAA,OACP1C,CADO0C,EACAC,CADAD,EACAE,CADAF;YACIG,MAEZlD,SAEgBmD,KAFhBnD,CAFYkD,IAIIC,QAJJD,KAIgBN,aAUzBjB,CACAyB,CADAzB,CAVyB,EAExBmB,YAAmBb,GAFK,EAELoB,EAAOC,OAAPD,CANXH;;YAMkBI,IAC7BV;cAAAA,eAAcW,IAAdX,EACAY,YAAaX,CAAbW,CADAZ,EAEAvC,CAAO,OAAIoD,GAAJ,CAOTtJ,cAPS,CAFPyI;YAUuBR,CAXMkB,CAWNlB,OACvBT,CADuBS,EACjB;cAAA;YAAQA;;YAAAA,IACdgB,CAAc,KAAdA,GAAkB5E,EAAlB4E,EAAsBhC,CAAQsC,KAARtC,KAAQsC,MADhBtB,EAEd;cAAAuB,QAAOC,aAKTjC,CAAIkC,CAAJlC,CALE,EAKEkC,YACIzB,GANN,EAM2BA,SAN3B;;cAOkB,IAElBQ;gBAAAA,uCAEOG,CAFPH;cAIA,CANkB,CAMlB,OACerB,CADf,EACeA;gBAAAA;cAAAA;YAAAA;UAAAA,CApCfqB,EAoCerB,EApCfqB,CAlCkB;QAsEHrB,CA9CD,EAANxD;MA8COwD,CAxEjBM,CAwEiBN;QAAAA,OAAmCa,OAChD,OADgDA,CAEzCwB,CAFyCxB,CAAnCb;MAENqC;IAAAA,CAlGE1C,EAkGF0C,CAGV,oBAHUA,GASXE;MAAAA;IAAAA,CA3Ga5C,EA2Gb4C,aACJ1C,UAEAjH,CAFAiH,EAEA;MAAAlG;QAAAA,2BAGI6I,CAHJ5I,EAGI4I;UAAAA;QAAAA,CAHJ5I;;QAGkC,OACZrC,OAAKkL,QAALlL,CAAKkL,KAAwB1G,UAAxB0G,CAAgCvL,IAAhCuL,EAC3BvL,IAD2BuL,CAALlL,CADY;MAE3BoC,CALPA,CAKOA;QAAAC,OADerC,OACVmL,OADUnL,CACVmL,CADUnL,CACfqC;MAAK8I;IAAAA,CAnHK/C,EAmHL+C,CADZC,WACYD,GADZ,UAIFE,CAJE,EAIFA;MAAAA;QAAAA;MAAAA;;MACE,OAAsBrL,KAAKkL,UAALlL,CAAKkL,EAAc5C,CAAd4C,CAALlL,EAA6BwE,IAA7BxE,CAAtB;IAAmDwE,CAvHlC4D,EAuH0CzI,WAC3D;MAAYwL;QAAAA,aADEG,aACFH,CAGRI,CAHQJ,EAGRI;UAAAA;QAAAA,CAHQJ;;QAIU,cAAKD,QAALlL,CAAKkL,KAAwB1G,UAAxB0G,CAAgCvL,IAAhCuL,EADMvL,IACNuL,CAALlL,EADWoC,IACXpC,CADWoC,aACXpC;MAAAA,CAJVmL,CAIUnL,OACXmL,CADWnL,EACXmL;QAAAA,OADGG,OADmB,OACnBA,CAEfjK,CAFeiK,CACHH;MACZ;IAAA,CA9HkB/C,EA8HlBzI;MAAA,2BAED6L,CAFC,EAEDA;QAAAA;QAASlD,OACPmD;UAAsBzL,aAAKkL,aACzB1G;QADFiH;MADFD,CAFC;;MAKGE,OAAUC,gBAAahM,IAAbgM,EAAgCC,IAAhCD,CAAVD;IAA0CE,CAnI3BxD,EAmI2BwD,mBAEhCT,CAFgCS,EAEhCT;MAAAA,2BAJZ9J,CAIY8J,EAGdU;QAAAA;MAAAA,CAHcV;;MAGT7C,OACmBtI,KAAKkL,UAALlL,CAAKkL,IAALlL,EAA4BL,CAAC6E,GAA7BxE,CADnBsI;IACgD9D,CAzIlC4D,EAyIkC5D,CAAQ,8BAARA,GAArC8G,UACdjK,CADciK,EACd;MAAA,OAGFQ,gBAHE;IAGFA,CA7ImB1D,EA6InB0D,6BAGS9L,UAAKiL,CAALjL,EAAKiL;MAAAA,OAGdc,gBAHcd;IAGdc,CAnJmB3D,EAmJnB2D,2BAGE,UAAYd,CAAZ,EAAYA;MAAAA,OAGde,gBAHcf;IAGde,CAzJmB5D,EAyJnB4D,yBAGE,UAAYf,CAAZ,EAAYA;MAAAA,OAAS3C,KAGvB2D,QAHuB3D,CAGvB2D,CAHuB3D,CAAT2C;IAGdgB,CA/JmB7D,EA+JnB6D,qBAGE,UAAOjM,CAAP,EAAOA;MAAKiL,YAAS3C,QAAT2C,CAGdiB,CAHcjB;IAGdiB,CArKmB9D,EAqKnB8D,kCACcjB,UAAS3C,CAAT2C,EAAS3C;MAGvB6D;IAAAA,CAzKmB/D,EAyKnB+D,wBAGE9K,CAHF,EAGE;MAAA,KAAY4J,eAAS3C,SAGfC,CAHeD,CAAT2C,EAGN1C,cAHM0C,EAGNrD,QAON3D,eAPM,EAHMgH,EAIGnC,IAAfsD,CAJYnB,EAImB3C,IAE/B+D,MAAkB,QAAlBA,CAA0BxD,CAA1BwD,CANA,EAQehF,MAAIpD,MARnB,EAQmBA,GARnB,EAQmBA;QAAAA,IAEnBqI,QAFmBrI;QAAAA,IAEEF,QAFFE;QAAAA,IAESC,QAFTD;QAEiB6E,0BAAelB,CAA9C,OAA8C,CAA9C0E,CAA8C,EAA9CA,CAA8C,CAAfxD;MAA/ByD;;MAAAA,OACHA,WAAS3E,EAALjG,QAAK,EAAT4K,EAAiB5H,CACflB,SADekB,EADd4H;IAEgB5H,CAxLJyD,EAwLIzD,CAKrB,cALqBA,GAIX6H,UAAgBpI,CAAhBoI,EAAgBpI,CAAhBoI,EAAgBpI;MACnBqI,IAAUrI,CAAVqI;MAAAA,IAAUrI,SAAVqI;MAAAA,IAAUrI,IAGX8G,WAHCuB;MAAAA,IAGDvB,mBAHCuB;MAAAA,IAOP3M,MAAO+I,kBAPA4D;MAAAA,IAOKnH,KAAWoH,IAA8CpE,CAA9CoE,CAPhBD;MAAAA,IAOgBC,aAPhBD;MAAAA,IAO+BE,IAA+BrE,EAA/BqE,MAP/BF;MAAAA,IAO+BE,gBAA+BrE,SACrDsE,IAAuBxE,KAAhCsD,OAAgCtD,QAD8BE,IAG/DoD,CAH+DpD,GAGrD,EAHsBqE,CAP/BF;MAUaI,YAAgC,QAAxB7M,CAAwB,GAAxBA,CAAwB,GAAnBoI,EAAbyE,EAAazE,OAAbyE,CAAqBnB,UAAWrK,CAAXqK,EAEzC/L,CAFyC+L,EAEzC;QAAImB,SAAQD,CAARC;MAAQD,CAFQC,GAERD,WAAmBjJ,QAAnBiJ,IAA2B/B,sBACpBiC,mCADoB,CAFnBD;MAON,SAAgB;QAAAvH;MAAA,KAAhB;;MAAgB;QAAA;UAI5BA,YAIF+B,CAJE/B,EAIF,MAAQqH,IACN1H,KADM0H,CACD,4BADCA,CAAR;UAIM9B,uBAAgB,yBAAhB;UAAgB;;QAGVkC,KACN,oBADMA;UAEG/L,IAAYsE,QAAaoH,CAAzB1L,EAAyB0L,MAGpC,IACFzH,KADE,CACG,4BADH,CAHoCyH;UAMlCM,kBAAgB3F,CAAhB;UAAgB;;QAAA;QAAA,UAGlB4F,CAHkB;QAGbP;UAAAA;;QAEL;UACF,MAAK,IACLzH,KADK,CACL,wBADK,CAAL;MA7B4B;;MAiC5B,OACE,IAAUA;QAAAA;QAAMyG,UAANzG;QAAMgI,qBAGpB,oBAIIvB,eAEasB,CAFbtB,CAJJ,CAHoB,GASH,KACP;MAVIzG,CAAV,CADF;IAWYhB,CA1PGmE,EA0PHnE,sBAAgBF,UAAOG,CAAPH,EAAekJ;MAAAA,aACnC7G,MAKJsC,uBALItC;MAKc2B,OACpBA,CADoBA;IACX+C,CAjQI1C,EAiQJ0C,eACD7F,UAAM6C,CAAN7C,EAAM6C,CAAN7C,EAAM6C;MAAAA;QAAaC,IAG/BtI,CAH+BsI;QAAAA,IAG/BrE,QAH+BqE;;QAMnBoD,eACZ+B;UAAAA,YACA5B,OADA4B,CAcAvN,SAdAuN;UAcAlN,CAXA,IAWAA,CAXS0L,QAWT1L,EAVE,kBAUFA,GAVmC0L,YACjCA,CASF1L;QATU+M,CANE5B,MAMExL,YAAU;UAAAwN;QAAA,CAAV;;QACGzB,OAEfJ,OAAKI,QAALJ,CAAgB6B,SAAQ1N,UAAR0N,IAAQ,KAPT,CAOCA,GAPD1N,aAOf6L,EAPejJ,IAOfiJ,CAPejJ,aAUMtB;UAAAA,eAAQqM,OAARrM,CAAqBuK,QAArBvK,EAVNgE,IAUMhE,CAVN;YAAA,wBAYWsM,CAZXjL,GAYWiL,CAZXtI,gBAYXsI,KAZW,CAajBC,CAAK5E,OAAL4E,GAAK5E,GAAL4E,GAAK5E,YAAL4E,GAEcC,IAFdD,GAGEpH,IAAM,UAAN,CACcsH,CADd,CAhBe;YAiBDA,OAAUzF,CAAVyF;UAAmBC,CAPZ1M;QAOY0M,CAVjCnC,CAFeI;MAYkB+B,CAzBjB3F,CAyBiB2F;QAAAA,OAAevH,OAAKO,OAALP,CAIlD7E,CAJkD6E,CAAfuH;MAInC;IAAA,CA/RiBrF,EA+RjB/G,CA/RiB+G;EA+RViF,CAhUX,EREuC;;EQ8T5BA;;EAAAA;IAAAA,SAjSFpI,CAiSEoI,CAjSFpI,CAiSEoI,EAjSM5F;MAAAA,KC1BXiG,MD0BWjG,GC1BXiG,MD0BWjG,EC1BXiG,cACJrM,CDyBeoG;ICzBf;;IAAA,UAAmBkG,SAAnB;IAAmBA,yBAAMA,CAAN3N;MAAA2N,IAELC,mBAkJhB,EAlJgBA,GAkJhBjO,CApJqBgO;MAAAA,IAoJrBjK,IAlJgBkK,WAFKD;MAAAA,IAGjB9J,qBAHiB8J;MAAAA,IAGjB9J,iBAHiB8J;MAAAA,IAI0B1E,IAA1C4E,iBAJgBF;;MAIhBE,IAAY;QAAA,QAAOC,IAAP;QAAOA,2CAEA9N,GAFA8N,CAAyBzM,CAAzByM,GAAyB1L,IAAzB0L,CAAyB1L,aAEzB8G;UAAAA,IAAKyE,CAALzE;;UAAKyE,SAAOI,CAAPJ,CAAOI,CAAPJ,EAAkBC;YAAAA,IAAI/J,CAAJ+J,EAAI/J,OAFFlE,CAEEkE;;YAFF;cAAA,kDAmBzCiK,MAnByC,CAoBrCzM,CApBqC,GAoBrCe,IApBqC4L,CAoBrC3L,YAAKsL,EApBgCK;YAoBhCL,CApBgC;;YAoBzBI,aAAkBlK,KAAlBkK,GAAkBlK,OApBOkB;cAAA;YAAA,CAoBPlB,CAAlBkK,GApByB1G,CAoBzB0G;UApByB;;UAAA;YAAAhJ;YAAAA;YAAAA,IAuBtC+H,gBApBM;cAATmB,IAOJ,MAAOnB,CAAP,IAA2BmB,CAApBnB,QAAOoB,GAAPpB,EAPHmB,EAOUC,wBACI,OADJA,CACSA,QADTA,GAC0BC,MAD1BD,CAEN7M,CAFM6M,GAEN9L,IAFM8L,CAEN7L,YAAKsL;gBAAAA,aAAOI,UAAkBlK,8BAAlBkK,CAAPJ;gBAETlO;cAAA,CAJUyO;YAIV,CASGpB,EAvBsC/H;;YAc/BE,OAASpB,8BAAToB;UAASpB;;UAAAA,IAdsBuK,CActBvK,EAdsB;QAKzC,CALgBiK;MAKhB,CALHD,CAKG,OAAU5I,CAAV,EAAUA;QAAAA,OAAJ7C,iBAAI6C;MAAJ;IAAA,CATO0I,EASPhO;MAAA;;MAAA;QAAA,OAqBSkE,gBAAyBqD,uBACtC6F,GADsC7F,CACtC7F,CADsC6F,EACtC9E;UAAAA,6BAAKuL,IAAL3N,KAAY+N,CAAZ3L;UAAY2L,OAAWhB;QAAvB3K,CADsC8E,CAAzBrD,EACcA,IADdA,CAEjBqK,YAAuB,CAAZhH,CAFMrD,CArBT;MAuBmB,CAvBnB,CAuBmB,OAASsK,CAAT,EAASA;QAAAA,OACpCrB,eAEHzL,CAFGyL,CADoCqB;MAGvC;IAAA,CAnCkBR,EAmClBhO,wBAEK0O;MAAAA;QAAAA,2CAAoB/F,CAApB+F,EAAoB/F,GAApB+F,GAAoB/F,IAApB+F,CAAoB/F,aAClBtI,CADFqO;MACErO,CADFqO,CACErO,OAAK+M,CAAL/M,EAAS;QAAA,cAAoB,OAApB,CAAoBqB,CAApB;MAAoB;IAAA,CAtClBsM,EAsCkBhO;MAAA,gBAErC2O,SAFqC,EAErCA;QAAAA;QAAAR,WACcF;MADdU,CAFqC;IAGvBV,CAzCKD,EAyCLC,EAAsBW,gBAAtBX,GACVC,UACAC,CADAD,EACAC;MAAAA;QAAAA,OAAa1L,OAIXmM,QAJW,CAIXA,KAAiBjG,GAAjBiG,CAAiBjG,gBAAjBiG,EACElN,CADFkN,EACEnM,GADFmM,CAJW,EAKTnM,IALS,CAKTC,YAAK0K,EALI,CAAbe;MAKa,CALbA,CAKa;QAAA,cAA2B,OAA3B,CAChBzM,CADgB;MAChB;IAAA,CAjDkBsM,EAiDlBhO,qBACD6O;MAAAA;QAAAX,WACE,EADF;QACEC,WAAYF,GAAmB;MADjC;IACiC,CAnDdD,EAmDchO,gBAC7BkO,aAAWlO,CAAXkO,EACAC;MAAAA;QAAAA,OAAa1L,OAIXqM,QAJW,CAIXA,uBAA+CpN,CAA/CoN,EAA+C9O,CAA/C8O,EAA+C,GAA/CA,CAJW,EAIoCrM,IAJpC,CAIoCC,YAC7CrC,EALS,CAAb8N;MAKSf,CALTe,CAKSf,OAAL1L,CAAK0L,EAAL;QAAA,OAAqBlI,OAAuB,OAAvBA,CADwBxD,CACxBwD,CAArB;MAD6C;IAAA,CAzDlC8I,EAyDkChO,gBAGrD+O;MAAAA;QAAAA,WAAY7J,EAAZ6J;QACEZ,WAAO9N,EAAK4N;MADdc;IAC8B7J,CA7DX8I,EA6DW9I,2BACf,UACXiJ,CADW,EACXA,CADW,EACXA,CADW,EACE;MAAA;QAAA,OAIXa,qBACJC,GADID,CACJC,yBAEA1H,CAHIyH,EAGJzH,CAHIyH,EAGJzH,CAHIyH,GAGJzH,IAHIyH,CAKE3O,YACmB4O,EANrBD,CAJW;MAUUC,CAVV,CAUUA;QAAAA,cAEvB1H,OAFuB0H,CAEvB1H,CAFuB0H;MAEvB1H;IAAAA,CA3EeyG,EA2EfzG;MAAAA,YAGJ2H,GAHI3H,CAGJ2H,0BAHI3H;IAGmB0H,CA9EJjB,EA8EIiB,CACrB,iBADqBA,GACd;MAAA;QAAA,KAAgCA,OAAhC;QAAA,IAGHE;UAAAA,oBAAiBC,GAAjBD;UAAiBC,QAUf,YAVFD;UAC+CE,KACjDC,SAFEH;UAEsB/I,QAAQmJ,GAChCC,QADgCD,CACtBH;QAHRD,CAHG;QAAA,IAMmBK,kBACHH,UAPhB;QAQLJ,OAAwB7I,OAAQqJ,QAARrJ,CAGMmI,kBAAiBC,UAAjBD,EAE1B9L,CAF0B8L,CAHNnI,EAKpB3D,IALoB2D,CAKpB1D,YAAK0K;UAAAA,IAAInF,SAAJmF;UAAI,OAAiC6B,OAAUS,QAAVT,CAC1CjP,uBACEF,CADF,CAD0CmP,EAExC7J,IAFwC6J,CAExCxM;YAAAkN,OAAKC,gBAAqBC,OAZezK,CAYfyK,EAZe/P,CAYf+P,EAZenO,CAYfmO,EAZe9L,CAYf8L,CAArBD,EAZoCxK,IAYpCwK,CAZoC,cAYpCA,CAALD;UAZyCjN,CAUDuM,CAAjC;QAVkCvM,CAKvB0D,CAAxB6I;MAL+CvM,CAH1C,CAG0CA;QAAAoN,OAa/CV,OAGHhK,OAHGgK,CAGH1N,CAHG0N,CAb+CU;MAgBlD;IAAA,CAlGkB9B,EAkGlBhO,wBACK+P;MAAAA;QAAAA;QAAAA,6BAAoBtH,UAApBsH,GAC2B1P,IAD3B0P,CAC2B1P;UAAAA,cAAiB,QAAjBA,CAAiBL,eAA1CgQ,UAA0C,EAEvBlQ,CAFuB,CAAjBO,EAENoC,IAFMpC,CAENoC,aAAKwN;YAAAA,aAC5BxH;cAAAA,IAAQwG,aAQH7J,QARG6J,EAARxG;cAAAA,IAQK1E,YARL0E;cAQK,eAAKuF,OAAL,CACJI,uBACa1M,CADb0M,CADI,EAEShJ,IAFT,CAES3C;gBAAAyN,OAAKN,YAALM;cAAKN,CAFd;YAEcA;;YAAAA,EAAqBnH,QAArBmH,GAdgC7L,CAchC6L;;YAdgC,oBAYrD;cAZqDO,mBAG7ClB,CAH6CkB,EAG7ClB,OAH6CmB,yBAQzCnB,QARyC,GAQ5Be,MAR4B,CAQ5BA,UAR4B,GAQ5BA,IAR4BI,CAS7CF,YAAY9B,EATiCgC,CAG7CnB;YAMYb,CATiC;;YASjCA,YAAkB1G,MAAlB0G,GAAkB1G,OAMvCtC,CANuC,CAAlBgJ,GAMrBnG,GANqBmG;UAMrB,CAdgC/N;QAchC,CAfK0P;MAeL,CAfKA,CAeL,OAfsDrO,CAetD,EAfsD;QAetD;MAAA2O;IAAAA,CAlHkBrC,EAkHlBqC;MAAAA;QAAAA;QAAAA,IACKC,SADLD;QACKC,uBACJ7H,uBAEYwF,CAFZxF,CADI6H,EAGQrC,IAHRqC,CAGQrC;UAAUsC,OAAKX;YAAAA,SAA3BxK;UAA2BwK,EAALW;QAAtB,CAHID;MAGJ,CAJDD,CAIC;QAAA,sBACEnC,CADFsC;MACEtC;IAAAA,CAvHeF,EAuHfE,EAAW0B,oBAAX1B,GAIU0B;MAAAA;QAAAA;QAAAA;QAAAA;QAAAA,IACZnH,cADYmH;QAIM,cAHWa,QAGXpQ,CAAK4P,iBAAL5P,EACN4O,IADM5O,CAHW;UAAAqC,cAKV,QALUA,CAKVqB,eALUrB,EAKV0C,IALU1C,CAKV;YAAA;YAAA;cAAAuM;cAHnBK,QAAwBoB,iCAAiB1Q,CACvCiP,OADuC,CACvCA,oBADuC,CAK7BxG,QAFO;cAEC6G,KAAYqB,GAAK3C,UAAO4C,WAAP5C,IAAO4C,CAAP5C,GAAO4C,SAAqBtB,oBAArBsB,CACnCF,KAD4B1C,CAFlB;cAIPqB,QAASsB,EAAK3C,SAAO4C,cAAP5C,IAAO4C,CAAP5C,GAAO4C,SAAqBvB,oBAArBuB,CAErBnI;YANO;UAMC+G,CAXS9M;QAWnBmO,CARQxQ;MAQcsQ,CAZpBf,CAYoBe,OAAK3C,CAAL2C,EAAYC;QAAAA,sBAAqBpB,CAArBoB;MAAqBpB;IAAAA,CAvIhDxB,EAuIgDwB;MAAAA;QAAAA,yBAIrDS,CAJqDT,EAIrDS,gBAAahB,mBAAbgB;QACgC,OAC1CxN,OAAM,QAAN,CAAgB,iBAAhB,CAD0C;MAC1B,CAN+C+M,CAM/C,UAGlB;QAAA,OAAOP,iBAAP;MAAOA;IAAAA,CAhJUjB,EAgJViB,CAhJUjB;EAgJViB,CD0KAvB;EAAAA,IC1KYsC,iBAIvB;IAAAvN;MAAAsL,KCxJqB+C,ODwJrB/C,GCxJqB+C,MDwJrB/C,ECxJqB+C,eACnBpP,CDuJFqM;ICvJE;;IAAA,IAAmBgD,eAAnB;IAAmBA,yBAAOA,CAAP1Q;MAAA0Q;MAEnB9C,eAAI/J,CAAJ,GACEqC,IAAM4G,CAAQ9M,KAAd,CAAmB0Q,CAAnB,CADF,GACqBA,IADrB9C;IAC6B+C,CAHVD,EAGUC,WAE3B,UAAatP,CAAb,EAAa;MAAA,OACJ6E,KAAK0K,OAAL1K,CAGF2K,UAHE3K,CAMX7E,CANW6E,GAMX,EAPe;IAOf,CAZmBwK,EAYnB/Q,QAEE,UADAK,CACA,EADAA,CACA,EADK0Q;MAAAA,OAAQG,aAAWhN,OAAXgN,CAIf9D,CAJe8D,EAIf3K,eAEEvG,CAFF,CAJekR,GAMb,IANKH;IAKL1Q,CAlBiB0Q,EAkBjB1Q,CAlBiB0Q;EAkBZA,CDqIT,EDsKWrD;EAAAA,IE3SFqD,WF2SErD;EAAAA,IE3SMyD,IAAQjN,aAAU4C,UAAV5C,EAEtB7D,OAFsB6D,EAEtB7D,UAFsB6D,CF2SdwJ;;EGhUY;IAAA;IC4CvB0D,kBAAsBA,mBACpB,EADF,EACQC,CAAKjQ,cAALiQ,CACHC,EADGD,GACHC,CAFL;EAEKA;;EAAAA,IAAgBD,CAAGC,4BACnBA;IAAAA;;IAGgBC;MAAAA;MAAAA,YA4CnBC,CA5CmBD,EA4CnB,KAAY9I,YAAZ,GAAkCgJ,WA5CfF,EA4CeG,WA3ClChB,KACQiB,CAFWJ,EAEXI,sBAAmB5D,KAAY1N,CAFpBkR,EAEoBlR,KA0CLA,oBA1CKA,GAEvCuR,MAJmBL,EAInBK,6BACAhB,MALmBW,EAKnBX,oBACAiB,MANmBN,EAMnBM,sBACAC,MAPmBP,EAOnBO,kBACAC,MARmBR,EAQnBQ,mBARmBR,EAQnBQ,KACAC,YADAD,GACAC,MATmBT,EAWnBU,sBACAC,iCAiCE7R,CAjCF6R,GAiCON,qCA7CYL,EA8CPK,KAAkBO,UAAlBP,GAAkB,qCAC5BvR,YAD4B,EA9CXkR,EA+CZS,KAALE,YAAKF,GAAqBA;QAAAA,OAA1BI,EAAwCH,KAAdD;QAAkBK,oBAEvCH,eAFuCG,IAG1CJ,CAH0CI,GAG1CJ;MAHwBD,CA/CTT,EAmDfe,oBAAmBA;QAAAA,QAAVC,EAAUD;QAAazG;MAAbyG,GAGrBjS,SAAKyR,kBAALzR,IACEmS,CADFnS,GACEmS,EAJmBF,CAnDJf,EAwDf1F,eAC4BtD,CAD5BsD,CAC4B;QAAAE,OAAxBtD,EAAQqJ;MAAgB,CAD5BjG,CAxDe0F,EAyDHO,4BAGH;QAAAxC,QACTvD,YADS;QAIX1L,YAAKuQ,gBAJM;QAKTtB,gBACAmD,qCACAC,CADAD,GACAC,iBAAgB,oBAAhBA,GACUA,MARD;QAOOC,MAELF,eAAe3S,QAAf2S,IAAelI,CAAfkI,GAAe,GATjB;QASiBG,MAAuB,WACjDC,YADiD,IACzCpK,CADyC,GACzCA,OAVC;QAUOoK,QAChBD,YAXS;QAWHE,WAAUF,IAAVG,WAXG;QAYTvD,YAAkBA,WAClBsD,kBADkBtD,IACGsD,CADHtD,GACGsD,UAbZ;QAcTE,OAAsC,SAAxBvK,MAAQuK,KAAgB,IAAhBA,CAAgB,GAAhBA;MAdb,CA5DMzB,EA0EuB,KACtClC,qBADsC,GACd;QAAA4D,iBAG1B5S,WAAKwR,uBAALxR,IACE4S,CADF5S,GACE4S,mBAEEnT,EAFe4R,qBAJO;QAKduB,qBACDxK,EAAQyK;MANO,CA3ET3B;MAkFf2B;MAAAA,sBAA+BA,4BAKjC7S;QAAK0R,iBAAiB,iCACpBoB;UAAAA,YAAmB,MAAIC,qBAAJ,CAAIA,YACrBC;YAAAA,QAAcvT,mBAAIwT,sBAAoBC,gBAAtCF,EACWG,KADXH,CAC+CC,MAD/CD,EAC+CC,cAACC,SAADD,CAD/CD;UACgDE,CAF/B,CAAnBJ;UAEkDI,cADV;YAAAE;cAAAC;gBAAAA,OAKtCC,gBACQF,gBACJG;kBACAC,IAHY;oBAAA,IAKR5L,+CALQ;kBAKRvF,CAFJmR,CAEInR;oBAAAA,QACoBoR,GADpBpR;kBACyBsP;;kBAAAA,YAAWyB,MAAXzB,GAAmB4B,EAAQC,IAARD,CAAQC,MAARD,EAAQC,CAARD,CAAnB5B,GAA2B6B,CAA3B7B;gBAA2B6B,CALpDJ,CAKoDI,CALpDJ,EAKoDI;kBAAAA,sCAH1CnS,WAMZ1B,sBACmB+T,mBAJmCF,EAK9C9L,OAASiM,EAATjM;kBAASiM;gBAAAA,CAVfP,CADRE,CALsCD;cAgBfM,CAhBeN,CAgBfM,OAAoBC,CAApBD,EAAoBC;gBAAAA,eAEnCrM,MAFmCqM,CAE5BvS,CAF4BuS;cAIrC;YAAA;UApBgC;QADxCd,CADoB;MAAtB9S,CALiC6S,CAA/BA;IA2Bc/H;;IAAAA,OAfIrL;MAAA8H,4BA7EtBwG,KA6EsB1M;MA7EtB0M,sBACW6D,KADX7D,EAEI,aAAY6D,kBAGLC,KAHP,CAFJ9D,KAKwB6D,QACpB5R,KAAK4R,YAAL5R,CAAkB6R,SADED;QACWA;UAEb5R,KAAK6R,KAAL7R,GAAK6R,MAAaI,mBAAbJ,CAAL7R;UAEX;;QACHA;UAA8Be,KAAO8S,KAAP9S,GAAO8S,YACrC,eADqCA,CAAP9S;UAE3B;;QACHf,KAAK4R,QAAL5R;UAAiByQ,KAAa1P,KAAb0P,GAAoBqD,SAApBrD;UAAoBqD;;QACrC;UACF,MAAK,UACElC,wBADF,CAAL;MAXkBA;MAclB,OACE,KAAU3M,KADZ;IACkB,CAyDF,EAzDExF,oCAIVmS,CAJU,EAIVA;MAAAA;QAAAA,QA4ERmC,IA5EQnC;QAAAA,IA4ERmC,kCACJ3L,CADI2L,CA5EQnC;QAAAA,IAiFPlO,cAjFOkO;QAgFMoC,OACRzD,yCAJoB7M,CAIpB6M,GAJoBnO,IAIpBmO,CAJoBnO,aAUI8G;UAAK2F,uBAAuBoF,iCAVhC7R,EAUgC6R,EAVhC5R,MAUgC4R,CAAvBpF,EAG/BwB,IAH+BxB,CAGnBtK;YAAAA;YAAAA;YAAAA,IAAmCzE,eAAnCyE;YAAAA,IAbUgF,kCAYb1E,iBAGW7D,EAHX6D,CAZa,EAaVN;YAAAA,IAEQvD,IAC1BqP,EAAc1J,WAAd0J,CAAc1J,OAAd0J,CAHkB9L;YAAAA,IAGyB9C;cAAAA;cAKjB4E,cAEM,EAEhCwC,CAT2CpH;cAS3CoH,KAAyBqL,GATkBzS;cASlByS,QATkBzS;cASlByS,kBACzBC,YADyBD,IACTrP,CADSqP,GAEzB7O,OAX2C5D;cAY3CiF,UAGA0N,GAf2C3S;cAe3C2S,SAASC,YAfkC5S;cAeX6S,aAChCC,gBAhB2C9S;cAmB3C6D,kBACAoH,oBApB2CjL;cAoBf2Q,OAC5BzF,UArB2ClL;cAqB3CkL,SAAoB0H,OArBuB5S;cAqBV4Q,YACjCmC,QAtB2C/S;cAsBlC4S,YACT9B,IAAQ8B,WAvBmC5S;cAwB3C0N,aAAuBA,gBAxBoB1N;cAyB3CmJ,KAA2B6H,SAzBgBhR;cAyBhBgR,qBACCE,QA1BelR;cA0BfkR,aACR3D,QA3BuBvN;cA8B3CgT,uBAAuBhV,CAAvBgV,GAAuB,KACvBC,CADAD,GACAC,aADAD,KAIAE,WAlC2ClT;cAkC3CkT,eAAcN,WAAcO,CAAdP,GAAcO,MAAdP,GAA6B5U,gBAA7B4U,KACdQ;YAnC2CpT,CAHzB8C;YAsClBsQ,OAAiBzS,iBAAc0S,aAAdT,CAAcS,mBAAdT,CAnDWjS,CAmDXiS,GAnDWhS,IAmDX,CAGb6G,YAAKoI;cAAAA,OAAajD,iBAAoB/F,aAApB+F,CAClBI,WADkBJ,CAClBvO,CADkBuO,EAClBjM,CADkBiM,GAClBjM,IADkBiM,CAClBhM,YAAKiP;gBAAAA;cAAAA,CADajD,CAAbiD;YACa7C,CAJL,CAAjBoG;UAIsBpG,CA7CeI;QA6CfJ,CAnDd8B,CADQyD;MAoDMvF,CApIZmD,CAoIYnD,OAAY5J,CAAZ4J,EAAuB7J;QAAAA,OAE/CxC,iBAF+CwC;MAExC0D;IAAAA,CAjFa,EAiFbA,mBAGHyM;MAAAA;;MAAAA;QAAAA;QACJ3M,OACAY,iBADAZ,UACAY,EAGsB5G,gBAHF3C,EAElB2I,qBAFkB,CAE+B/G,CAF/B,CAGE,EAD6B0D,IAC7B,CAD6B,aAC7BiQ;UAAAA,OAAKjB,gBAAsB3L,MAH7BrD,kBAG6BqD,CAH7B/G,CAG6B+G,EAH7BzI,CAG6ByI,CAAtB2L,EAHP3R,IAGO2R,CAHP1R,UAIG2S,CAJH3S,EAIQ4S;YAAAA,OAAIlM,gBAA4BC,0BAChC3H,CADgC2H,EAChC5G,CADgC4G,CAA5BD,CAAJkM;UACA7S,CAFD2R,CAALiB;QAEM5S,CAFN,CAJtBgG;MAM4B/F,CAPxB0S,CAOwB1S;QAAA2S,OAAKE,iBAALF;MAA6B1M;IAAAA,CA3FrC,EA2F8CP,oBAK9DoN,CAL8DpN,EAK9DoN;MAAAA;;MAAAA;QAAAA;QAAM/M,yBAAiC2L,qBAAjC3L,CAAmC/G,CAAnC+G,GAAmChG,IAAnCgG,CAAmChG,aACLgT;UAAAA,SAAKrB,CAALqB,GAAKrB;YAAAA,gBAAvCzL,IAAuCyL,GAAvCzL,CAAuCyL;UAAvCzL;;UAAAA,UAQNvH,GARMuH,CAQNvH,iBARMuH,CAQCe,CARDf;UAAAA,IAQCe,gBANP;YAAA,IAAMR,cAAeR,uBAArB,EAEI,cAAkC,QAAlC,CAAkChH,iBAAnBgU,CAAmB,CAAlC,EALyCtQ,IAKzC,CALyC,cAKzC;UALyC1C,CAStCgH,EARDf;;UADuCjG,OAM7BgT,eAAexM,KAAfwM,CAIjBtQ,CAJiBsQ,IAIjB3R,GAV8CrB;QAU9C,CAVW+F;MAUX,CAVK+M,CAUL,UALK;QAAA,OAKL/S,iBALK;MAKL2C;IAAAuQ,CA1GqB,EA0GrBA,kBAEKC;MAAAA;QAAAA;QAAAA;QAAAA,6BACJnN,CADImN,GACJnN,MADImN,GACJnN,CAAuC,IADnCmN,IACmC5V,CADnC4V,GACmCC,MAK/BxV,SAL+BwV,CAE9BlM,IAHLiM;QAGK,OAAGnN,gBAAgBrH,eAAOsI,mBAAPtI,EAAhBqH,EAF2B/F,IAE3B+F,CAF2B/F,UAK1BiP,CAL0BjP,EAK1BiP;UAAAA,IAAahD,CAAbgD;UAAahD,oCALa3O,KAIjC2I,IAJiC,CAOvCG,kCAPuC,CAQ3BgN,CAR2B,EAKbnH,KAIR2G;YAAAA,IAAIxM,2BAAJwM,EAAIxM,UAAmCI,KAAnCJ,CACf,2BADeA;YAIpB9I,UAAUsF,+BAAV,CAAgBvB,CAAhB;UAAgB;UAAA,OAFAuR,OAAIrM,QAAJqM,CAAIrM,0BAXiBvH,CAWjBuH,EAMCxG,CANDwG,CAAJqM,EAMK7S,IANL6S,CAMK5S,UAAK6S,CAAL7S,EAAK6S;YAAAA;cAAAA,eAAwB5M,CAAxB4M;cAAiCnN,KAD7DhD;YAC4BmQ;UAA1BnG,CANgBkG,CAEA;QAIhBlG,CAfU3G,CAAH;MAeP2G,CAlBEwG,CAkBFxG,UAAa2G;QAAAA,OACNrF,OAAcrK,OAAdqK,CAA6B/H,CAA7B+H,CADMqF;MAC+BhP;IAAAA,CA/H1B,EA+H0BA;MAAAA;QAAAA,IAI1CwO,QAJ0CxO;QAI1CwO,+BAEJnN,UAMkC4N,oBANlC5N,CAFImN;QAI2BxO,OAC7BtE,OAAM,QAAN,CAAgB3C,yBAHS4B,YAGT,CAAhB,EAHyBgB,IAGzB,CAGgCsT,UAAK9G,CAAL8G,EAAK9G;UAAAA;UAAAA,IACrCvG,CAAQiM,uBAD6B1F;UAAAA,IANZ5F,mBAMY4F;UAAAA,IAUtBnH,KAFKY,UARiBuG;UAAAA,IAQTlC,oBARSkC;UAOdnC,cADZpE,CAAQhD,OACIoH,CADJpH,EADdsQ,YACctQ,CADMuQ,WACNvQ,CAZMjE,gBAYNiE,CACIoH,EAIG4E,IAJH5E,CAIG4E,UAAa5C,CAAb4C,EAAa5C;YAAAA,cAC7ByF,QAD6BzF,CAC7ByF,MAlBepP,6BAkBfoP,CAMJ9R;cAAAA;cAAAA,SAASyJ,GAATzJ;cAASyJ,gBAATzJ;cAASyJ,kBAZfxG,GAYMjD;cAZNiD,UACAoH,sBAWMrK;cAVNsK,OAUMtK;cAVNsK,aACAmJ,GASMzT;cATMuI;YASNvI,CANI8R,CAD6BzF,EAAvCqH,IAAuCrH,CAAvCqH,UAGAnL,CAHAmL,EAGAnL;cAAAA,cAAsBA,QAAtBA,CAAsBA,gBAGlBoL,UAHkBpL,EAMFyF,UANEzF,EAMFyF,OANEzF,EAMUxF,WANVwF,CAAtBA,EAOAgL,IAPAhL,CAOoBjF,UACNH,CADMG,EACNH;gBAAAA,KACd8C;kBAAQjD,WACAC,gBADRgD;kBAHIvC,WAONkQ,IAAMlH,IAAN,KACEmH,kBALA5N;kBAK2BsD,OAG3BsC,GARA5F;kBAQA4F,OAAW+H,UARX3N;kBAQmD6G,QAAbgH;gBARtC7N,CADc9C;gBAUdO,OACAiJ,OAA2B1G,QAA3B0G,CACAG,eAAkBA,gBAAlBA,CAxCyB/M,CAwCzB+M,CADAH,EAvCyB3M,IAuCzB2M,CAvCyB3M,YA2ChBiP;kBAAAA,OAAaxC,CAAbwC;gBAAaxC,CAJtBE,CADAjJ;cAKsB+I,CAvBtBlE;YAuBsBkE,CA1BiBJ;UA0BjBI,CA9BCpC;QA8BDoC,CAxCtB,CAD6BpI;MAyCPoI,CAjDsBpI,CAiDtBoI,OAAiBC,CAAjBD,EAAiBC;QA3CdhK,sBA6C3B1D,CA7C2B;MA6CpB0N;IAAAA,CAlLa,EAkLbA;MAAAA;QAAAA;QAAAA,IAGHF;UAAAA,sBAAuBD,QAAvBC,CASwBD,CARxBwH,IAQwBxH,eARxBwH,CAQwBxH,OARxBwH,CAQwBxH,CARxBwH,EAQwBxH,gBARxBwH,IASMC,KAAK3E,oBAAerP,mCAAfqP,CAAL2E,CAEC9E,IAFD8E,CAEC9E,UAAiBlQ,CAAjBkQ,EAAiB;YAAA,gCACtBxM,OADsB,CACjB,UACLuR,mCADK,CADiB;UAICrR,CANnBoR,CAVNxH,EAgByB5J,IAhBzB4J,CAgB+B;YAAA,sCAhBSF,sBAgBT,CAhBStM,QAmBtCgU,CAnBsChU,GAmBjCiP,CAnBiCjP,GAmBjCiP,EAHwB,EAGxBA,CAHwB,EAGxBA,YAAa3C,sBACtBC,MADS0C,GACG5N,eAEwByO,MAH3Bb,GAG2B,IANH,GAMrBG,IANqB,CAMrBA,YACR4E;cAAAA,OAAK5E,CAAL4E;YAAK5E,CAPwB;UAOxBA,CAvBP5C;QAuBO4C,CA1BJ1C;QAAAA,IA0BiBoD,QA1BjBpD;QAAAA,IA2BDnH,gBAxBsC;UAAA,mBA2BrCgO,MA3BqC,EACxCS,wBAAK5E,aAAL4E,CAAkBlE,sBAAlBkE,CADwChU,QAGlCgU,CAHkChU,GAG7BiP,CAH6BjP,GAG7BiP,EAFX+E,GAEW/E,IAFXtB,CAEWsB,UAAazC,CAAbyC,EAAazC;YAAAA,cAAlBlP,QAAkBkP;UAAuBD,CAF/CoB;QAE+CpB,CAqB7C,EA3BCG;;QAMwD,OADvD6G,gBAEFA,KACKA,MADLA,GACKA,SADLA,GAHFnW,CADwC,GAEpCmW,CACuD;MAHnB,CAHrC7G,CAGqC;QAAA3M;MAAA2C;IAAAwR,CArLxB,EAqLwBA;MAAAvG;;MA8BxCjB;QAAAA,uBACJ3G,kBAAgC6H,gBAAhC7H,CAEAhG,CAFAgG,CADI2G;MAGJ1M,CAHI0M,CAGJ1M,OAAOrC,CAAPqC,EAAOrC;QAAAA,OAAKsR,OAAarB,OAAbqB,CAAarB,CAAbqB,CAALtR;MAAkBiQ;IAAAA,CAtNL,EAsNKA,SAAiB7H,UAGtCoO,CAHsCpO,EAGtCoO;MAAAA;;MAAAA;QAAAA;QAAAA;QAAAA,IAAKpO,iCAAuB,SA4BJ,YA5BI,EAC1BqO,aAD0B,EACTA,aADS,EAE9B,UAF8B,EAG9B,oBAH8B,EAK9B,SAL8B,EAK9B,SAL8B,EAM9B,SAN8B,EAO9B,OAP8B,EAO9B,gBAP8B,EAS9B,QAT8B,EAU9B,WAV8B,EAW9B,UAX8B,EAY9B,QAZ8B,EAY9B,cAZ8B,EAc9B,uBAd8B,EAgB9B,SAhB8B,EAiB9B,YAjB8B,EAkB9B,gBAlB8B,EAkB9B,kBAlB8B,EAoB9B,iBApB8B,EAqB9B,mBArB8B,EAsB9B,mBAtB8B,CAA5BD;QAuBF,OACApU,gBACA3C,kBADA,EACAsF,IADA,CAxBgC,UA4BN3C,CA5BM,EA4BNC;UAAAA;YAAAwN,GAAKd;UAAL1M;;UAAmB+F,IAAzC2G,eAENvD,QAF+CpD,EAG7CgH;YAAAA,KAAmBrJ,QAAQqJ,OAA3BA,EAIF,EAAIS,IAAK4B,GAAT,EAASA,IAJPrC,GAIOqC;cAAAA,IAAajG,WAAbiG;cACPpQ,iBAAoBoV,CAApB5P,GAAoB4P,GAApB3P,UAAW4P,CAAX5P;YAAW4P;;YAAAA,OAAiB5J,CAAjB4J;UAAiB5J;;UAAAA,OACR/G,OAAQ2Q,QAAR3Q,CACgBA,yBAtCJ1E,UA6CAe,GAPI2D,CADhBA,EAQY1D,IARZ0D,CAQiB8I;YAAAA,cACvB9I,QADuB8I,CACfO,MA9CUrK,QA8CVqK,CA9CU;cAAA9J,kCAyDN2P,QAzDM;cAyDFzJ,aAPnBqE,EAAKU,uBAAqBtB,YAlDL;cAmDhCvC,kBAAoB6D,yBAAqB6B,gBAnDT;cAoDhCzF,YAAyB4D,eApDO;cAoDc8B;YApDd,CA8CVjD,CADeP,EAQrCjD,IARqCiD,CAQTqH;cAC5BrN,KAAK+M,IAAoBe,CAApBf,EAAoBe,QAAzB9N,EAAyB8N,eAAzB9N,GAGId;gBAAAA;gBAEN1G,gBAAoBoV,IAApB;cAAAG;;cAAAA;YAAA7P,CAduC8H;UAcX,CAtBN9I,CADQ+G;QAuBnB4J,CAnCT,CADA;MAoCSA,CA3DPF,CA2DOE,OACT5J,CADS4J,EACT5J;QAAAA,OAAa4J,OACO3O,OADP2O,CAKfrV,CALeqV,CAAb5J;MAKF;IAAA,CA1RoB,EA0RbtB,uBAGHqL;MAAAA;QAAAA;QAAAA,uBAAmBzO,gBACKpI,CADLoI,CAAnByO,EACwB7W,IADxB6W,CACwB;UAAAxU,cAAK0M,QAALmB,CAAmB9H,yBAEb3I,aAFa2I,CAAnB8H,EAEM7N,IAFN6N,CAEWrB;YAAAA;YAAAA,YACvB9I,sBADuB8I,EAHM,gBAOG,iCAPH;YAQjC5J,iBAAM2C,2BAAN3C,IAAM2C,CAAN3C,GAAMtF,EAGlB6R,qBAHkB,CAIRqB,qBAJE5N;YAKLuM,+BAAsBqB,wCAAtBrB;YAGKvM,IAAMgE;cAAA3D;cAGZgD,aACO4H,EAAKK,uBAAqBtB,YAJrB;cAKhBvC,kBAAoB6D,yBAAqB6B,gBALzB;cAMhBzF,KAAoBuD,EAAKK,oBANT;cAM8B8B,yBACrByE,KAPT;cAOSA,wBACzBC,GARgB;cAQhBA,KAA6BhR,gBAC7BiR,OAD6BjR;YARb,CAANd;YASV+R,cACAtQ,QADAsQ,CACqB3Q,eAAoBK,gBAApBL,CAGjBjE,CAHiBiE,CADrB2Q,EAII3U,IAJJ2U,CAII3U,YAAKiP;cAAAA,OAAa/C,CAAb+C;YAAa/C,CAJtByI;UAIsBzI,CA5BI2B;QA4BJ3B,CA7BpBsI;MA6BoBtI,CA7BpBsI,CA6BoBtI;QAAiBjG,OAEzCvD,iBAFyCuD;MAEzC;IAAA,CA5ToB,EA4TbA;MAAAA;MAAAA,SAGH2O,SAHG3O;MAAAA,IAGH2O,cAHG3O;MAAAA,IAGH2O,WAHG3O;MAAAA,IAGH2O,KAMsB,SATnB3O;MAAAA,IAIP2G,WAJO3G;;MAKPsG;QAAAA;QAAAA,QACAI,aACAG;UAAAA,eACG/G,OACyBiE,QADzBjE,CACyB+B,uBADzB/B,EACyB8O,IADzB9O,CACyBhG;YAAAC,SAaDwU,CAbCxU,GAaDwU;cAAAA,cAbC9R,QAaD8R,CAbC1M,qCAaD0M,EAbCxU,IAaDwU,CAQrBvG,YAAKgB;gBAAAA,MAAa5B,SAAb4B,CAAa5B,IAAb4B,GAAa5B,CAAb4B;cAAa5B,CARGmH;YAQiBrH;;YAAAA,IArBhBzK,yBAuBrBsE,CAvBqBtE,CAqBgByK;YAAAA,IAErCnG,gBAAgBR;cAAAA,IARvB,cAAqBL,uBAQEK,EAvBK,cAiBgB,QAjBhB,CAiBgBgC,iBAAnBwK,CAAmB,CAjBhB,EAkBpB8B,IAlBoB,CAkBpBA,cAlBoB;YAkBpBA,CAKD9N,EAFqCmG;;YAHpC2H,OAAc9B,eAAexM,KAAfwM,CAlBMtQ,CAkBNsQ,IAlBM1V,GAkBpBwX;UAlBoB,CADzB/O,CADH+G;QAE4B,CAJ5BP;QAAAA,IAI4BzE,QAJ5ByE;QAAAA,IAI4B/D,qCAJ5B+D;QAAAA,IAI4BwI;UAAA9G,QACtB6G,EACDnD,CAFuBoD;UAEvBxI,QAAK4C,GAFkB4F;UAElB5F,QAFkB4F;UAElB5F,QACLpJ;QAHuBgP,CAJ5BxI;QAAAA,IAUMY,CAAuB,GAACP;UAAUL,0BAAiBO,OAErDkI,iBAACF,aAAD,CAAevE,mBAAf,CARwBxQ,CAQxB,GARwBC,IAQxBgV,CACI/G,YAAKgB;YAAAA;UAAa5B,CADtB2H,CAFqDlI;QAG/BO,CAHIT,EAV9BL;;QAa0Bc,eAAoBF,OAApBE,CAe3B3K,0BAhBKmF,CAgBL,GAf2BwF;MAe3B,CA5BCd,CA4BD;QAAAxM;MAAA2C;IAAAuS,CA7VqB,EA6VrBA,mBAEKC;MAAAA;;MAAAA;QAAAA;QAAAA;QAAAA,KAAkBnP,OAAlBmP;QAAAA,IAAkBnP,mCAAiC,KAAE,CAAnCA,GAAmC3I,KAAnC2I,IAAmCoP,CAAnCpP,GAGepI,MAF/B6I,CAAGQ,QAE4BrJ,CAFzBsJ,IADRiO;QACQ,uBAAgBxW,eAAOsI,gBAAPtI,EAAhBqH,EAEyBhG,IAFzBgG,CAEyB/F,UAAKiP,CAALjP,EAAKiP;UAAAA,SAAa9C,IAAb8C,CAAa9C,+BAAb8C,CAE1C1J,CAF0C0J;UAE1C,OACO2D,OAAIrM,QAAJqM,CAAIrM,uBAN8CvH,CAM9CuH,EAN8CjJ,CAM9CiJ,CAAJqM,EAED7S,IAFC6S,CAED7S;YAAAoV,OAAKC,eAAqBnP,MAArBmP,CAALD;UAAmCzP,CAFlCkN,CADP;QAGyClN,CAP7BK;MAO6BL,CARrCwP,CAQqCxP;QAAAA,OAEzC3F,OAAqB4D,OAArB,CAAoCsC,CAApC,CAFyCP;MAEGrB;IAAAA,CAzWxB,EAyWwBA;MAAAA;QAAAA,MAGxC+Q,KAHwC/Q,KAGxC+Q,OAHwC/Q,EAGxC+Q,gBAEJ1P,oBAFI0P;QAI2B/Q,OAC7BtE,OAAU6C,QAAV,EAD6ByB;MACb,CAR0BA,CAQ1B;QAAA,cAHM,OAGN,CAHMtE,CAGN;MAHMC;IAAAA,CA9WJ,EA8WIA,CA/VRyI;EA+VQzI,CAhdJ4O,EAAnBA;;EAgduB5O;AAAAA","names":["r","message","t","name","_class2","s","_this","this","g","_","w","String","Array","buf","from","fromCharCode","apply","Uint8Array","b","TextEncoder","getWindow","P","window","toBase64","str","toUrlEncodedBase64","replace","S","e","crypto","O","msCrypto","getRandomBytes","length","k","getRandomValues","A","getCrypto","subtle","_getCrypto$subtle","webkitSubtle","digestOp","digest","Promise","resolve","rej","oncomplete","res","target","result","onerror","T","I","atob","textDecoder","TextDecoder","Set","arr","sort","join","uniqueElementsFromArray","trim","split","objectFromURLSearchParams","params","n","forEach","obj","key","getAll","Object","object","URLSearchParams","entries","filter","toString","C","_ref","createCodeChallengeAndVerifier","method","map","j","v","verifier","challenge","buffer","then","textEncoder","Error","getCryptoSubtle","sha256","verifyIdToken","nonce","client_id","jwtVerify","id_token","createRemoteJWKSet","URL","jwks_uri","audience","payload","x","idToken","decodeState","_state$split","JSON","decodeURIComponent","undefined","encodeState","R","fromBase64","encodeURIComponent","stringify","state","stringFromBuffer","objectFromEntries","_step","_iterator","done","objectToKey","fn","timeout","factor","retries","i","err","reject","setTimeout","ApiError","code","description","o","uri","fromResponse","response","error_description","error_uri","W","Api","options","buildAuthorizeUrl","request","_buildUrl","buildLogoutUrl","parseAuthorizeResponseFromFragment","_validateResponse","substring","parseAuthorizeResponseFromQuery","url","searchParams","authorizeWithPopup","config","u","_this2","popup","_config$timeout","location","href","c","_config$width","width","open","screenX","innerWidth","screenY","clearInterval","timeoutId","recievedMessage","close","a","l","PopupTimeoutError","setInterval","redirectUrl","_popup","closed","intervalId","clearTimeout","PopupClosedError","redirect_uri","f","error","hash","authorizeWithDevice","getToken","_buildRequest","_fetchJSON","_this4$_buildRequest","introspect","init","revoke","userinfo","_this$_buildRequest2","headers","Authorization","access_token","jwks","getTokenWithAuthorizationCode","getTokenWithRefreshToken","getTokenWithDeviceCode","getTokenWithPassword","getTokenWithSAML","getTokenWithClientCredentials","_objectWithoutPropertiesLoose","_excluded","_i","_Object$entries$_i","search","urlObject","client_secret","client_auth_method","headersInit","Headers","value","set","h","body","input","Accept","fetch","json","_this8","ok","status","statusText","ClientStore","client","get","mustExist","deleteAfter","getStore","_result","entry","expiresAt","now","_exit","setAuthorizeRequest","getAuthorizeRequest","setLogoutRequest","getLogoutRequest","setVerifier","getVerifier","setOpenIdConfiguration","username","getOpenIdConfiguration","setAuthorization","authorization","scope","clientID","aud","resource","sub","expiresIn","_this14","_getAuthorizationKey","authorizationOptions","call","deleteAuthorization","fallbackUsername","_getUsername","_this16","_delete","_this15$_getUsername","_temp6","getAuthorization","_this18","_get2","_getUsername3","util","_this20","fallbackLoginOptions","_options$resource","StorageStore","storage","getItem","parse","removeItem","setItem","H","_w","UAUTH_VERSION","Client","q","_options$cacheOptions","_options$rpInitiatedL","_clientStore","fallbackIssuer","fallbackLogoutOptions","cacheOptions","issuerResolver","resolution","store","storeOptions","_options$fallbackIssu","_options$resolution","Resolution","storeType","_options$storeType","issuer","clientSecret","clientAuthMethod","_options$clientAuthMe","prompt","maxAge","redirectUri","_options$prompt","responseMode","rpInitiatedLogout","postLogoutRedirectUri","webfingerResolver","DefaultWebFingerResolver","ipfsResolver","DefaultIPFSResolver","defaultCreateUrl","createIpfsUrl","records","arguments","domainResolver","domain","keys","self","ResolutionError","ResolutionErrorCode","UnspecifiedResolver","localStorage","sessionStorage","buildAuthorizeRequest","_extends","loginHint","authorization_endpoint","code_challenge","flow_id","loginOptions","_loginOptions$flowId","login_hint","max_age","code_challenge_method","response_type","package_name","packageName","package_version","packageVersion","loginWithPopup","_this4","api","verifyAuthorizeResponse","login","_this6","beforeRedirect","_temp2","loginCallback","_options$url","response_mode","_this7$verifyAuthoriz","_this10","openidConfiguration","token_endpoint","grant_type","code_verifier","tokenResponse","Date","accessToken","expires_in","_exit2","_this12","resp","_temp5","user","claims","claim","userinfo_endpoint","_iterator2","buildLogoutRequest","end_session_endpoint","id_token_hint","post_logout_redirect_uri","logout","_exit4","logoutOptions","_temp8","_temp13","_temp12","logoutCallback","_this22","verifyLogoutResponse"],"sources":["../src/errors/createError.ts","../src/errors/errors.ts","../src/util/encoding/stringFromBuffer.ts","../src/util/encoding/textEncoder.ts","../src/util/getWindow.ts","../src/util/encoding/toBase64.ts","../src/util/encoding/toUrlEncodedBase64.ts","../src/util/crypto/getCrypto.ts","../src/util/crypto/getRandomBytes.ts","../src/util/crypto/getCryptoSubtle.ts","../src/util/crypto/sha256.ts","../src/util/crypto/createCodeChallengeAndVerifier.ts","../src/util/encoding/fromBase64.ts","../src/util/encoding/textDecoder.ts","../src/util/uniqueElementsFromArray.ts","../src/util/getSortedScope.ts","../src/util/objectFromURLSearchParams.ts","../src/util/objectToKey.ts","../src/util/index.ts","../src/util/crypto/verifyIdToken.ts","../src/util/encoding/decodeState.ts","../src/util/encoding/encodeState.ts","../src/util/objectFromEntries.ts","../src/util/retry.ts","../src/api/ApiError.ts","../src/api/Api.ts","../src/ClientStore.ts","../src/store/StorageStore.ts","../src/version.ts","../src/Client.ts"],"sourcesContent":["export default function createError(name: string, message: string) {\n  return class extends Error {\n    name = name\n    constructor() {\n      super(message)\n    }\n  }\n}\n","import createError from './createError'\n\nexport const PopupTimeoutError = createError(\n  'PopupTimeoutError',\n  'The popup has timed out.',\n)\n\nexport const PopupClosedError = createError(\n  'PopupClosedError',\n  'The popup was closed.',\n)\n","const stringFromBuffer = (buf: ArrayBuffer): string =>\n  String.fromCharCode.apply(null, Array.from(new Uint8Array(buf)))\n\nexport default stringFromBuffer\n","const textEncoder = new TextEncoder()\n\nexport default textEncoder\n","import window from 'global'\n\nconst getWindow: () => Window & typeof globalThis = () => window\n\nexport default getWindow\n","import getWindow from '../getWindow'\n\nconst toBase64 = (str: string) => getWindow().btoa(str)\n\nexport default toBase64\n","import toBase64 from './toBase64'\n\nconst toUrlEncodedBase64 = (str: string) => {\n  return toBase64(str)\n    .replace(/=+$/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n}\n\nexport default toUrlEncodedBase64\n","import getWindow from '../getWindow'\n\n//ie 11.x uses msCrypto\nconst getCrypto = () =>\n  (getWindow().crypto ?? (getWindow() as any).msCrypto) as Crypto\n\nexport default getCrypto\n","import getCrypto from './getCrypto'\n\nconst getRandomBytes = (length: number): Uint8Array =>\n  getCrypto().getRandomValues(new Uint8Array(length))\n\nexport default getRandomBytes\n","import getCrypto from './getCrypto'\n\n//safari 10.x uses webkitSubtle\nconst getCryptoSubtle = () =>\n  getCrypto().subtle ?? (getCrypto() as any).webkitSubtle\n\nexport default getCryptoSubtle\n","import getWindow from '../getWindow'\nimport getCryptoSubtle from './getCryptoSubtle'\n\nconst sha256 = async (buf: ArrayBuffer): Promise<ArrayBuffer> => {\n  const digestOp: any = getCryptoSubtle().digest({name: 'SHA-256'}, buf)\n\n  // This is for legacy IE Hashing\n  if ((getWindow() as any).msCrypto) {\n    return new Promise((res, rej) => {\n      digestOp.oncomplete = (e: any) => res(e.target.result)\n      digestOp.onerror = (e: ErrorEvent) => rej(e.error)\n      digestOp.onabort = () => rej('The digest operation was aborted')\n    })\n  }\n\n  return await digestOp\n}\n\nexport default sha256\n","import type {CodeChallengeMethod} from '../../types'\nimport stringFromBuffer from '../encoding/stringFromBuffer'\nimport textEncoder from '../encoding/textEncoder'\nimport toUrlEncodedBase64 from '../encoding/toUrlEncodedBase64'\nimport getRandomBytes from './getRandomBytes'\nimport sha256 from './sha256'\n\nconst pkceMask =\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.'\n\nconst createCodeVerifier = (length: number) => {\n  return Array.from(getRandomBytes(length))\n    .map(v => pkceMask[v % pkceMask.length])\n    .join('')\n}\n\nconst createCodeChallengeAndVerifier = async (\n  length = 43,\n  method: CodeChallengeMethod = 'S256',\n): Promise<{verifier: string; challenge: string}> => {\n  const verifier = createCodeVerifier(length)\n\n  switch (method) {\n    case 'plain':\n      return {verifier, challenge: verifier}\n    case 'S256':\n      return {\n        verifier,\n        challenge: toUrlEncodedBase64(\n          stringFromBuffer(await sha256(textEncoder.encode(verifier).buffer)),\n        ),\n      }\n    default:\n      throw new Error('bad challenge method')\n  }\n}\n\nexport default createCodeChallengeAndVerifier\n","import getWindow from '../getWindow'\n\nconst fromBase64 = (str: string): string => getWindow().atob(str)\n\nexport default fromBase64\n","const textDecoder = new TextDecoder()\n\nexport default textDecoder\n","export default function uniqueElementsFromArray<T>(arr: T[]): T[] {\n  return Array.from(new Set(arr))\n}\n","import uniqueElementsFromArray from './uniqueElementsFromArray'\n\nconst getSortedScope = (scope: string) =>\n  uniqueElementsFromArray(scope.trim().split(/\\s+/)).sort().join(' ')\n\nexport default getSortedScope\n","export default function objectFromURLSearchParams(\n  params: URLSearchParams,\n): Record<string, string | string[]> {\n  const obj = {}\n\n  params.forEach((_, key) => {\n    if (params.getAll(key).length > 1) {\n      obj[key] = params.getAll(key)\n    } else {\n      obj[key] = params.get(key)\n    }\n  })\n\n  return obj\n}\n","export default function objectToKey(object: Record<PropertyKey, any>): string {\n  const params = new URLSearchParams(\n    [...Object.entries(object)].filter(([k, v]) => k != null && v != null),\n  )\n  params.sort()\n  return params.toString()\n}\n","import createCodeChallengeAndVerifier from './crypto/createCodeChallengeAndVerifier'\nimport getCrypto from './crypto/getCrypto'\nimport getCryptoSubtle from './crypto/getCryptoSubtle'\nimport getRandomBytes from './crypto/getRandomBytes'\nimport sha256 from './crypto/sha256'\nimport verifyIdToken from './crypto/verifyIdToken'\nimport decodeState from './encoding/decodeState'\nimport encodeState from './encoding/encodeState'\nimport fromBase64 from './encoding/fromBase64'\nimport stringFromBuffer from './encoding/stringFromBuffer'\nimport textDecoder from './encoding/textDecoder'\nimport textEncoder from './encoding/textEncoder'\nimport toBase64 from './encoding/toBase64'\nimport toUrlEncodedBase64 from './encoding/toUrlEncodedBase64'\n\nconst crypto = {\n  createCodeChallengeAndVerifier,\n  getCrypto,\n  getCryptoSubtle,\n  getRandomBytes,\n  sha256,\n  verifyIdToken,\n}\n\nconst encoding = {\n  decodeState,\n  encodeState,\n  fromBase64,\n  textDecoder,\n  textEncoder,\n  toBase64,\n  toUrlEncodedBase64,\n  stringFromBuffer,\n}\n\nexport {default as getSortedScope} from './getSortedScope'\nexport {default as getWindow} from './getWindow'\nexport {default as objectFromEntries} from './objectFromEntries'\nexport {default as objectFromURLSearchParams} from './objectFromURLSearchParams'\nexport {default as objectToKey} from './objectToKey'\nexport {default as retry} from './retry'\nexport {default as uniqueElementsFromArray} from './uniqueElementsFromArray'\nexport {crypto, encoding}\n","import {IdToken} from '@uauth/common'\nimport {jwtVerify, createRemoteJWKSet} from 'jose'\n\nconst verifyIdToken = async (\n  jwks_uri: string,\n  id_token: string,\n  nonce: string,\n  client_id: string,\n) => {\n  const {payload} = await jwtVerify(\n    id_token,\n    createRemoteJWKSet(new URL(jwks_uri)),\n    {audience: client_id},\n  )\n\n  const idToken: IdToken = payload as any\n\n  idToken.__raw = id_token\n\n  if (nonce !== idToken.nonce) {\n    throw new Error(\"nonces don't match\")\n  }\n\n  return idToken\n}\n\nexport default verifyIdToken\n","import fromBase64 from './fromBase64'\n\nconst decodeState = <T>(state: string): T => {\n  const [, v, ...b] = state.split('.')\n\n  if (b.length > 0) {\n    throw new Error('failed to decode state')\n  }\n\n  return v?.length > 0\n    ? JSON.parse(decodeURIComponent(/* unescape */ fromBase64(v)))\n    : undefined\n}\n\nexport default decodeState\n","import getRandomBytes from '../crypto/getRandomBytes'\nimport stringFromBuffer from './stringFromBuffer'\nimport toUrlEncodedBase64 from './toUrlEncodedBase64'\n\nconst encodeState = <T>(state: T): string =>\n  `${toUrlEncodedBase64(stringFromBuffer(getRandomBytes(32)))}.${\n    state == null\n      ? ''\n      : toUrlEncodedBase64(\n          /* escape */ encodeURIComponent(JSON.stringify(state)),\n        )\n  }`\n\nexport default encodeState\n","export default function objectFromEntries<T = any>(\n  entries: Iterable<readonly [PropertyKey, T]>,\n): Record<PropertyKey, T> {\n  const object: Record<PropertyKey, T> = {}\n  for (const [k, v] of entries) {\n    object[k] = v\n  }\n  return object\n}\n","function retry<T>(\n  fn: () => Promise<T>,\n  retries = 4,\n  timeout = 250,\n  factor = 2,\n  err = null,\n): Promise<T> {\n  if (retries <= 0) {\n    return Promise.reject(err)\n  }\n\n  return fn().catch(async err => {\n    await new Promise(r => setTimeout(r, timeout))\n    return retry(fn, retries - 1, timeout * factor, factor, err)\n  })\n}\n\nexport default retry\n","import {ErrorResponse} from './types'\n\nexport default class ApiError extends Error {\n  constructor(\n    public code: string,\n    public description: string,\n    public uri?: string,\n  ) {\n    super(`${code}: ${description}${uri ? `\\nSee more at ${uri}.` : ''}`)\n  }\n\n  static fromResponse(response: ErrorResponse) {\n    return new ApiError(\n      response.error,\n      response.error_description,\n      response.error_uri,\n    )\n  }\n}\n","import {PopupClosedError, PopupTimeoutError} from '../errors/errors'\nimport {UserInfo} from '../types'\nimport {objectFromURLSearchParams} from '../util'\nimport toBase64 from '../util/encoding/toBase64'\nimport ApiError from './ApiError'\nimport {\n  ApiOptions,\n  AuthorizeRequest,\n  AuthorizeResponse,\n  AuthorizeWithDeviceRequest,\n  AuthorizeWithDeviceResponse,\n  BaseRequest,\n  IntrospectRequest,\n  IntrospectResponse,\n  JWKSRequest,\n  JWKSResponse,\n  LogoutRequest,\n  PopupConfig,\n  RevokeRequest,\n  TokenRequest,\n  TokenResponse,\n  TokenWithAuthorizationCodeRequest,\n  TokenWithClientCredentialsRequest,\n  TokenWithDeviceCodeRequest,\n  TokenWithPasswordRequest,\n  TokenWithRefreshTokenRequest,\n  TokenWithSAMLRequest,\n  UserInfoRequest,\n} from './types'\n\nexport default class Api {\n  static Error = ApiError\n\n  constructor(public options: ApiOptions) {}\n\n  buildAuthorizeUrl(request: AuthorizeRequest): string {\n    return this._buildUrl(request)\n  }\n\n  buildLogoutUrl(request: LogoutRequest): string {\n    return this._buildUrl(request)\n  }\n\n  parseAuthorizeResponseFromFragment(url: string): AuthorizeResponse {\n    return this._validateResponse(\n      objectFromURLSearchParams(\n        new URLSearchParams(new URL(url).hash.substring(1)),\n      ),\n    )\n  }\n\n  parseAuthorizeResponseFromQuery(url: string): AuthorizeResponse {\n    return this._validateResponse(\n      objectFromURLSearchParams(new URL(url).searchParams),\n    )\n  }\n\n  async authorizeWithPopup(\n    request: AuthorizeRequest,\n    config: PopupConfig = {},\n  ): Promise<AuthorizeResponse> {\n    if (!window) {\n      throw new Error('no window in options')\n    }\n\n    const url = this.buildAuthorizeUrl(request)\n\n    let popup: Window | undefined | null = config.popup\n    const timeout: number = config.timeout ?? 3600000\n\n    if (!popup) {\n      const width = config.width ?? 600\n      const height = config.height ?? 800\n\n      popup = window.open(\n        url,\n        'uauth:authorize:popup',\n        `left=${window.screenX + (window.innerWidth - width) / 2},top=${\n          window.screenY + (window.innerHeight - height) / 2\n        },width=${width},height=${height},resizable,scrollbars=yes,status=1`,\n      )\n\n      if (!popup) {\n        throw new Error('popup failed to be constructed')\n      }\n    } else {\n      popup.location.href = url\n    }\n\n    let recievedMessage = false\n    const response: AuthorizeResponse = await new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        if (!recievedMessage) {\n          clearInterval(intervalId)\n          popup!.close()\n          reject(new PopupTimeoutError())\n        }\n      }, timeout)\n\n      const intervalId = setInterval(() => {\n        // Check if popup is closed\n        if (!recievedMessage && popup?.closed) {\n          clearInterval(intervalId)\n          clearTimeout(timeoutId)\n          reject(new PopupClosedError())\n        }\n\n        // Check if popup doesn't violate the \"Same-Origin\" policy and has a valid url\n        let href: string\n        let url: URL\n        let redirectUrl: URL\n        try {\n          href = popup!.location.href\n          url = new URL(href)\n          redirectUrl = new URL(request.redirect_uri)\n        } catch (error) {\n          return // Exit if not\n        }\n\n        // Check to see that the redirect was correct\n        url.hash = ''\n        if (url.href === redirectUrl.href) {\n          recievedMessage = true\n\n          clearInterval(intervalId)\n          clearTimeout(timeoutId)\n          popup!.close()\n\n          try {\n            resolve(this.parseAuthorizeResponseFromFragment(href))\n          } catch (error) {\n            reject(error)\n          }\n        }\n      }, 10)\n    })\n\n    return response\n  }\n\n  async authorizeWithDevice(\n    request: AuthorizeWithDeviceRequest,\n  ): Promise<AuthorizeWithDeviceResponse> {\n    return {} as any\n  }\n\n  async getToken(request: TokenRequest): Promise<TokenResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    return this._fetchJSON(input, init)\n  }\n\n  introspect(request: IntrospectRequest): Promise<IntrospectResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    return this._fetchJSON(input, init)\n  }\n\n  async revoke(request: RevokeRequest): Promise<void> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    await this._fetchJSON(input, init)\n  }\n\n  userinfo(request: UserInfoRequest): Promise<UserInfo> {\n    const [input, init] = this._buildRequest(request, {\n      method: 'GET',\n      headers: {Authorization: `Basic ${request.access_token}`},\n    })\n    return this._fetchJSON(input, init)\n  }\n\n  jwks(request: JWKSRequest): Promise<JWKSResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'GET'})\n    return this._fetchJSON(input, init)\n  }\n\n  getTokenWithAuthorizationCode(\n    request: TokenWithAuthorizationCodeRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithRefreshToken(\n    request: TokenWithRefreshTokenRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithDeviceCode(\n    request: TokenWithDeviceCodeRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithPassword(\n    request: TokenWithPasswordRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithSAML(request: TokenWithSAMLRequest): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithClientCredentials(\n    request: TokenWithClientCredentialsRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  private _buildUrl(request: BaseRequest): string {\n    const {url, ...searchParams} = request\n\n    const urlObject = new URL(url)\n\n    const params = new URLSearchParams()\n\n    for (const [k, v] of Object.entries(searchParams)) {\n      if (k != null && v != null) {\n        params.append(k, v)\n      }\n    }\n\n    urlObject.search = params.toString()\n    return urlObject.toString()\n  }\n\n  private _buildRequest(\n    request: BaseRequest,\n    options: {method: 'GET' | 'POST'; headers?: HeadersInit},\n  ): [RequestInfo, RequestInit] {\n    const {url, client_id, client_secret, client_auth_method, ...rest} = request\n    const {headers: headersInit, method} = options\n\n    const headers = new Headers(this.options.headers ?? [])\n\n    new Headers(headersInit ?? []).forEach((value, key) => {\n      headers.set(key, value)\n    })\n\n    if (options.method === 'POST') {\n      headers.set('Content-Type', 'application/x-www-form-urlencoded')\n    }\n\n    const body: Record<string, any> = {\n      client_id,\n      ...rest,\n    }\n\n    switch (client_auth_method) {\n      case 'client_secret_basic':\n        // throw new Error('only client_secret_post supported')\n        if (client_secret == null) {\n          throw new Error('Client secret not present!')\n        }\n\n        headers.set(\n          'Authorization',\n          `Basic ${toBase64(`${client_id}:${client_secret}`)}`,\n        )\n\n        break\n      case 'client_secret_post':\n        if (client_secret == null) {\n          throw new Error('Client secret not present!')\n        }\n\n        body.client_secret = client_secret\n\n        break\n      case 'none':\n      case undefined:\n      case null:\n        break\n      default:\n        throw new Error('Bad client_auth_method')\n    }\n\n    return [\n      url,\n      {\n        method,\n        headers,\n        body:\n          method === 'POST'\n            ? new URLSearchParams(Object.entries(body))\n            : undefined,\n      },\n    ]\n  }\n\n  private _validateResponse(response: any) {\n    if (response.error) {\n      throw Api.Error.fromResponse(response)\n    }\n\n    return response\n  }\n\n  private async _fetchJSON(\n    input: RequestInfo,\n    init: RequestInit,\n  ): Promise<any> {\n    if (init.headers) {\n      const headers = new Headers(init.headers)\n      headers.set('Accept', 'application/json')\n      init.headers = headers\n    } else {\n      init.headers = {Accept: 'application/json'}\n    }\n\n    const response = await window?.fetch(input, init)\n\n    const json = await response.json()\n    this._validateResponse(json)\n\n    if (!response.ok) {\n      throw new Error(\n        `${response.status} ${response.statusText}: ${JSON.stringify(json)}`,\n      )\n    }\n\n    return json\n  }\n}\n","import {AuthorizeRequest, LogoutRequest} from './api'\nimport type Client from './Client'\nimport {Authorization, AuthorizationOptions} from './types'\nimport * as util from './util'\n\nclass ClientStore {\n  constructor(public client: Client) {}\n\n  private async get<T>(\n    key: string,\n    {mustExist = false, deleteAfter = false} = {},\n  ): Promise<T | undefined> {\n    const entry = await this.client.getStore().get(key)\n    if (entry == null) {\n      if (mustExist) {\n        throw new Error(`${key} does not exist in store`)\n      }\n      return\n    }\n\n    const {value, expiresAt} = entry\n    if (expiresAt !== 0 && expiresAt < Date.now()) {\n      await this.client.getStore().delete(key)\n      if (mustExist) {\n        throw new Error(`${key} does not exist in store`)\n      }\n      return\n    }\n\n    if (deleteAfter) {\n      await this.client.getStore().delete(key)\n    }\n\n    return value\n  }\n\n  private async set<T>(key: string, value: any, timeout = 0) {\n    await this.client.getStore().set(key, {\n      expiresAt: timeout === 0 ? 0 : Date.now() + timeout,\n      value,\n    })\n  }\n\n  async setAuthorizeRequest(request: AuthorizeRequest): Promise<void> {\n    await this.set('request', request, 300_000 /* 5 minutes */)\n  }\n  getAuthorizeRequest(): Promise<AuthorizeRequest> {\n    return this.get<AuthorizeRequest>('request', {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<AuthorizeRequest>\n  }\n\n  async setLogoutRequest(request: LogoutRequest): Promise<void> {\n    await this.set('logout-request', request, 300_000 /* 5 minutes */)\n  }\n  getLogoutRequest(): Promise<LogoutRequest> {\n    return this.get<LogoutRequest>('logout-request', {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<LogoutRequest>\n  }\n\n  async setVerifier(challenge: string, verifier: string): Promise<void> {\n    await this.set(`verifier:${challenge}`, verifier, 300_000 /* 5 minutes */)\n  }\n  getVerifier(challenge: string): Promise<string> {\n    return this.get(`verifier:${challenge}`, {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<string>\n  }\n\n  async setOpenIdConfiguration(\n    username: string,\n    openidConfiguration: any,\n    timeout: number,\n  ): Promise<void> {\n    await this.set(\n      `openidConfiguration:${username}`,\n      openidConfiguration,\n      timeout,\n    )\n  }\n  getOpenIdConfiguration(username: string): Promise<any> {\n    return this.get(`openidConfiguration:${username}`)\n  }\n\n  async setAuthorization(authorization: Authorization): Promise<void> {\n    const authorizationOptions: AuthorizationOptions = {\n      clientID: authorization.idToken.aud,\n      resource: authorization.resource,\n      scope: authorization.scope,\n      username: authorization.idToken.sub,\n    }\n\n    const expiresIn = authorization.expiresAt - Date.now()\n\n    await this.set('username', authorizationOptions.username, expiresIn)\n    await this.set(\n      await this._getAuthorizationKey(authorizationOptions),\n      authorization,\n      expiresIn,\n    )\n  }\n  async deleteAuthorization(options: AuthorizationOptions): Promise<boolean> {\n    const fallbackUsername = await this.get<string>('username')\n\n    options.username = await this._getUsername(\n      options.username,\n      fallbackUsername,\n    )\n\n    if (options.username === fallbackUsername) {\n      await this.client.getStore().delete('username')\n    }\n\n    return this.client\n      .getStore()\n      .delete(await this._getAuthorizationKey(options))\n  }\n  async getAuthorization(\n    options: AuthorizationOptions,\n  ): Promise<Authorization> {\n    return this.get(await this._getAuthorizationKey(options), {\n      mustExist: true,\n    }) as Promise<Authorization>\n  }\n\n  private async _getAuthorizationKey(\n    options: AuthorizationOptions,\n  ): Promise<string> {\n    return `authorization?${util.objectToKey({\n      username: await this._getUsername(\n        options.username,\n        await this.get('username'),\n      ),\n      clientID: options.clientID ?? this.client.fallbackLoginOptions.clientID,\n      scope: util.getSortedScope(\n        options.scope ?? this.client.fallbackLoginOptions.scope,\n      ),\n      resource: options.resource ?? this.client.fallbackLoginOptions.resource,\n    })}`\n  }\n\n  private async _getUsername(username?: string, fallbackUsername?: string) {\n    if (username == null && fallbackUsername == null) {\n      throw new Error('no username given')\n    }\n\n    return username ?? fallbackUsername\n  }\n}\n\nexport default ClientStore\n","import {Store} from './types'\n\nexport default class StorageStore implements Store {\n  constructor(public storage: Storage) {}\n\n  get(key: string): string | null {\n    const value = this.storage.getItem(key)\n\n    if (value != null) {\n      return JSON.parse(value)\n    }\n\n    return null\n  }\n\n  delete(key: string): boolean {\n    this.storage.removeItem(key)\n    return true\n  }\n\n  set(key: string, value): this {\n    this.storage.setItem(key, JSON.stringify(value))\n    return this\n  }\n}\n","export const VERSION = \"2.2.0\";\n","import {\n  DefaultIPFSResolver,\n  DefaultIssuerResolver,\n  DefaultWebFingerResolver,\n  DomainResolver,\n  IssuerResolver,\n} from '@uauth/common'\nimport {\n  Resolution,\n  ResolutionError,\n  ResolutionErrorCode,\n} from '@unstoppabledomains/resolution'\nimport {\n  Api,\n  AuthorizeRequest,\n  AuthorizeResponse,\n  LogoutRequest,\n  LogoutResponse,\n  PopupConfig,\n  TokenResponse,\n  TokenWithAuthorizationCodeRequest,\n  UserInfoRequest,\n} from './api'\nimport ClientStore from './ClientStore'\nimport {StorageStore, Store, StoreType} from './store'\nimport {\n  Authorization,\n  AuthorizationOptions,\n  BaseLoginOptions,\n  BaseLogoutOptions,\n  CacheOptions,\n  ClientOptions,\n  FullLoginOptions,\n  LoginCallbackOptions,\n  LoginCallbackResponse,\n  LoginOptions,\n  LogoutCallbackOptions,\n  LogoutOptions,\n  UserInfo,\n  UserOptions,\n} from './types'\nimport * as util from './util'\nimport {VERSION} from './version'\n\nif (typeof window !== 'undefined') {\n  const _w = window as any\n  _w.UAUTH_VERSION = _w.UAUTH_VERSION || {}\n  _w.UAUTH_VERSION.JS = VERSION\n}\n\nexport default class Client {\n  util = util\n  private _clientStore = new ClientStore(this)\n  api: Api\n  fallbackIssuer: string\n  fallbackLoginOptions: BaseLoginOptions\n  fallbackLogoutOptions: BaseLogoutOptions\n  cacheOptions: CacheOptions\n  issuerResolver: IssuerResolver\n  resolution: DomainResolver\n\n  store?: Store\n  storeOptions: {\n    store?: Store\n    storeType: StoreType\n  }\n\n  getStore(): Store {\n    if (this.store) {\n      return this.store\n    }\n\n    if (this.storeOptions.store) {\n      this.store = this.storeOptions.store\n    } else {\n      const storeType = this.storeOptions.storeType\n      switch (storeType) {\n        case 'localstore':\n          this.store = new StorageStore(window.localStorage)\n          break\n        case 'sessionstore':\n          this.store = new StorageStore(window.sessionStorage)\n          break\n        case 'memory':\n          this.store = new Map<string, string>()\n          break\n        default:\n          throw new Error('Bad storeType provided')\n      }\n    }\n\n    return this.store\n  }\n\n  constructor(options: ClientOptions) {\n    this.fallbackIssuer =\n      options.fallbackIssuer ?? 'https://auth.unstoppabledomains.com'\n    this.resolution = options.resolution ?? new Resolution()\n\n    this.storeOptions = {\n      store: options.store,\n      storeType: options.storeType ?? 'localstore',\n    }\n\n    this.cacheOptions = {\n      issuer: false,\n      userinfo: true,\n      ...(options.cacheOptions ?? {}),\n    }\n\n    this.api = new Api({\n      headers: {},\n    })\n\n    this.fallbackLoginOptions = {\n      clientID: options.clientID,\n      clientSecret: options.clientSecret,\n      clientAuthMethod:\n        options.clientAuthMethod ??\n        (options.clientSecret ? 'client_secret_post' : 'none'),\n      maxAge: options.maxAge ?? 300000,\n      prompt: options.prompt ?? 'login',\n      resource: options.resource,\n      redirectUri: options.redirectUri,\n      responseMode: options.responseMode ?? 'fragment',\n      scope: options.scope ?? 'openid wallet',\n    }\n\n    this.fallbackLogoutOptions = {\n      rpInitiatedLogout:\n        options.rpInitiatedLogout ??\n        typeof options.postLogoutRedirectUri === 'string',\n      postLogoutRedirectUri: options.postLogoutRedirectUri,\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    this.issuerResolver = new DefaultIssuerResolver({\n      webfingerResolver: new DefaultWebFingerResolver({\n        ipfsResolver: new DefaultIPFSResolver((...args) =>\n          (options.createIpfsUrl || DefaultIPFSResolver.defaultCreateUrl)(\n            ...args,\n          ),\n        ),\n        domainResolver: {\n          async records(\n            domain: string,\n            keys: string[],\n          ): Promise<Record<string, string>> {\n            try {\n              const records = await self.resolution.records(domain, keys)\n              return records\n            } catch (error) {\n              if (\n                error instanceof ResolutionError &&\n                error.code === ResolutionErrorCode.UnspecifiedResolver\n              ) {\n                return {}\n              }\n              throw error\n            }\n          },\n        },\n      }),\n    })\n  }\n\n  async buildAuthorizeRequest(\n    options: Partial<LoginOptions>,\n  ): Promise<AuthorizeRequest> {\n    // TODO: Ensure nothing is missing\n    const loginOptions: FullLoginOptions = {\n      ...this.fallbackLoginOptions,\n      ...options,\n    } as FullLoginOptions\n\n    const loginHint = options.username\n\n    const openidConfiguration = await this.getOpenIdConfiguration(loginHint)\n\n    const {verifier, challenge} =\n      await util.crypto.createCodeChallengeAndVerifier(43, 'S256')\n\n    const nonce = util.encoding.toBase64(\n      util.encoding.stringFromBuffer(util.crypto.getRandomBytes(32)),\n\n      /* util.encoding.textDecoder.decode */\n    )\n\n    const state = util.encoding.encodeState(loginOptions.state)\n\n    const request: AuthorizeRequest = {\n      // Generated options\n      url: openidConfiguration.authorization_endpoint,\n      code_challenge: challenge,\n      nonce,\n      state,\n\n      // Builder options\n      flow_id: loginOptions.flowId ?? 'login',\n      login_hint: loginHint,\n\n      // Parameterized options\n      client_id: loginOptions.clientID,\n      client_secret: loginOptions.clientSecret,\n      client_auth_method: loginOptions.clientAuthMethod,\n      max_age: loginOptions.maxAge,\n      prompt: loginOptions.prompt,\n      resource: loginOptions.resource,\n      redirect_uri: loginOptions.redirectUri,\n      response_mode: loginOptions.responseMode,\n      scope: loginOptions.scope,\n\n      // Constant options\n      code_challenge_method: 'S256',\n      response_type: 'code',\n\n      // package info\n      package_name: loginOptions?.packageName || '@uauth/js',\n      package_version: loginOptions?.packageVersion || VERSION,\n    }\n\n    await this._clientStore.setAuthorizeRequest(request)\n    await this._clientStore.setVerifier(challenge, verifier)\n\n    return request\n  }\n\n  async loginWithPopup(\n    options: Partial<Omit<LoginOptions, 'responseMode'>> = {},\n    config?: PopupConfig,\n  ): Promise<Authorization> {\n    ;(options as Partial<LoginOptions>).responseMode = 'fragment'\n    const request = await this.buildAuthorizeRequest(options)\n    const response = await this.api.authorizeWithPopup(request, config)\n    const authorization = await this.verifyAuthorizeResponse(request, response)\n\n    return authorization\n  }\n\n  async login(options: Partial<LoginOptions> = {}): Promise<void> {\n    const request: AuthorizeRequest = await this.buildAuthorizeRequest(options)\n\n    const url = this.api.buildAuthorizeUrl(request)\n\n    if (typeof options.beforeRedirect === 'function') {\n      await options.beforeRedirect(url)\n    }\n\n    window.location.href = url\n  }\n\n  async loginCallback<T>(\n    options?: Partial<LoginCallbackOptions>,\n  ): Promise<LoginCallbackResponse<T>> {\n    const url = options?.url ?? window.location.href\n\n    const request: AuthorizeRequest =\n      await this._clientStore.getAuthorizeRequest()\n\n    let response: AuthorizeResponse\n    if (request.response_mode === 'fragment') {\n      response = this.api.parseAuthorizeResponseFromFragment(url)\n    } else if (request.response_mode === 'query') {\n      response = this.api.parseAuthorizeResponseFromQuery(url)\n    } else {\n      throw new Error('Unsupported response_mode')\n    }\n\n    return {\n      authorization: await this.verifyAuthorizeResponse(request, response),\n      state: util.encoding.decodeState<T>(request.state),\n    }\n  }\n\n  async verifyAuthorizeResponse(\n    request: AuthorizeRequest,\n    response: AuthorizeResponse,\n  ): Promise<Authorization> {\n    if (request.state !== response.state) {\n      throw new Error(\"states don't match\")\n    }\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      request.login_hint,\n    )\n\n    const tokenRequest: TokenWithAuthorizationCodeRequest = {\n      url: openidConfiguration.token_endpoint,\n      client_id: request.client_id,\n      client_secret: request.client_secret,\n      client_auth_method: request.client_auth_method,\n      grant_type: 'authorization_code',\n      code: response.code,\n      code_verifier: await this._clientStore.getVerifier(\n        request.code_challenge,\n      ),\n      redirect_uri: request.redirect_uri,\n    }\n\n    const tokenResponse: TokenResponse =\n      await this.api.getTokenWithAuthorizationCode(tokenRequest)\n\n    const idToken = await util.crypto.verifyIdToken(\n      openidConfiguration.jwks_uri,\n      tokenResponse.id_token!,\n      request.nonce,\n      request.client_id,\n    )\n\n    const authorization: Authorization = {\n      accessToken: tokenResponse.access_token,\n      // TODO: The server isn't returning the scope along with the callback and\n      // I havn't found the oidc docs to figure out if this is a bug.\n      expiresAt: Date.now() + tokenResponse.expires_in * 1000,\n      idToken,\n      scope: util.getSortedScope(request.scope),\n      resource: request.resource,\n    }\n\n    await this._clientStore.setAuthorization(authorization)\n\n    return authorization\n  }\n\n  async getOpenIdConfiguration(username?: string): Promise<any> {\n    if (this.cacheOptions.issuer) {\n      const openidConfiguration =\n        await this._clientStore.getOpenIdConfiguration(username ?? '')\n      if (openidConfiguration) {\n        return openidConfiguration\n      }\n    }\n\n    const openidConfiguration = username\n      ? await this.issuerResolver.resolve(username, this.fallbackIssuer)\n      : await fetch(\n          this.fallbackIssuer + '/.well-known/openid-configuration',\n        ).then(resp =>\n          resp.ok\n            ? resp.json()\n            : Promise.reject(new Error('bad openid-configuration response')),\n        )\n\n    await this._clientStore.setOpenIdConfiguration(\n      username ?? '',\n      openidConfiguration,\n      typeof this.cacheOptions.issuer === 'number'\n        ? this.cacheOptions.issuer\n        : 3600_000,\n    )\n\n    return openidConfiguration\n  }\n\n  async authorization(\n    options: AuthorizationOptions = {},\n  ): Promise<Authorization> {\n    return this._clientStore.getAuthorization(options)\n  }\n\n  async user(options: UserOptions = {}): Promise<UserInfo> {\n    const claims = options.claims ?? [\n      'name',\n      'given_name',\n      'family_name',\n      'middle_name',\n      'nickname',\n      'preferred_username',\n      'profile',\n      'picture',\n      'website',\n      'email',\n      'email_verified',\n      'gender',\n      'birthdate',\n      'zoneinfo',\n      'locale',\n      'phone_number',\n      'phone_number_verified',\n      'address',\n      'updated_at',\n      'wallet_address',\n      'wallet_type_hint',\n      'eip4361_message',\n      'eip4361_signature',\n      'humanity_check_id',\n    ]\n\n    const authorization = await this.authorization(options)\n\n    const userinfo: UserInfo = {\n      sub: authorization.idToken.sub,\n    }\n\n    // If we should only read from cache.\n    if (this.cacheOptions.userinfo) {\n      for (const claim of claims) {\n        if (authorization.idToken[claim]) {\n          userinfo[claim] = authorization.idToken[claim]\n        }\n      }\n\n      return userinfo\n    }\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      authorization.idToken.sub,\n    )\n\n    const request: UserInfoRequest = {\n      client_id: this.fallbackLoginOptions.clientID,\n      client_secret: this.fallbackLoginOptions.clientSecret,\n      client_auth_method: this.fallbackLoginOptions.clientAuthMethod,\n      access_token: authorization.accessToken,\n      url: openidConfiguration.userinfo_endpoint,\n    }\n\n    const response = await this.api.userinfo(request)\n\n    for (const claim of claims) {\n      if (response[claim]) {\n        userinfo[claim] = response[claim]\n      }\n    }\n\n    return userinfo\n  }\n\n  async buildLogoutRequest(options: LogoutOptions): Promise<LogoutRequest> {\n    const authorization = await this.authorization(options)\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      authorization.idToken.sub,\n    )\n\n    if (openidConfiguration.end_session_endpoint == null) {\n      throw new Error('end_session_endpoint must exist')\n    }\n\n    const postLogoutRedirectUri =\n      options.postLogoutRedirectUri ??\n      this.fallbackLogoutOptions.postLogoutRedirectUri\n\n    if (postLogoutRedirectUri == null) {\n      throw new Error('postLogoutRedirectUri must be supplied')\n    }\n\n    const request: LogoutRequest = {\n      client_id: this.fallbackLoginOptions.clientID,\n      client_secret: this.fallbackLoginOptions.clientSecret,\n      client_auth_method: this.fallbackLoginOptions.clientAuthMethod,\n      url: openidConfiguration.end_session_endpoint,\n      id_token_hint: authorization.idToken.__raw,\n      post_logout_redirect_uri: postLogoutRedirectUri,\n      state: util.encoding.encodeState(options.state),\n    }\n\n    await this._clientStore.setLogoutRequest(request)\n\n    return request\n  }\n\n  async logout({\n    clientID,\n    username,\n    scope,\n    resource,\n    ...options\n  }: Partial<LogoutOptions> = {}): Promise<void> {\n    const logoutOptions: LogoutOptions = {\n      ...this.fallbackLogoutOptions,\n      ...options,\n    }\n\n    const authorizationOptions = {clientID, username, scope, resource}\n\n    if (!logoutOptions.rpInitiatedLogout) {\n      await this._clientStore.deleteAuthorization(authorizationOptions)\n      return\n    }\n\n    const request = await this.buildLogoutRequest(logoutOptions)\n\n    const url = this.api.buildLogoutUrl(request)\n\n    if (typeof logoutOptions.beforeRedirect === 'function') {\n      await logoutOptions.beforeRedirect(url)\n    }\n\n    await this._clientStore.deleteAuthorization(authorizationOptions)\n\n    window.location.href = url\n  }\n\n  async logoutCallback<T>(options: LogoutCallbackOptions = {}): Promise<T> {\n    const url = options?.url ?? window.location.href\n\n    const request: LogoutRequest = await this._clientStore.getLogoutRequest()\n\n    const response: AuthorizeResponse =\n      this.api.parseAuthorizeResponseFromQuery(url)\n\n    await this.verifyLogoutResponse(request, response)\n\n    return util.encoding.decodeState<T>(request.state)\n  }\n\n  async verifyLogoutResponse(\n    request: LogoutRequest,\n    response: LogoutResponse,\n  ): Promise<void> {\n    if (request.state !== response.state) {\n      throw new Error(\"states don't match\")\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}