{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullAddress = '0x0000000000000000000000000000000000000000';\nvar NullAddresses;\n\n(function (NullAddresses) {\n  NullAddresses[NullAddresses[\"0x\"] = 0] = \"0x\";\n  NullAddresses[NullAddresses[\"0x0000000000000000000000000000000000000000\"] = 1] = \"0x0000000000000000000000000000000000000000\";\n  NullAddresses[NullAddresses[\"0x0000000000000000000000000000000000000000000000000000000000000000\"] = 2] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n})(NullAddresses = exports.NullAddresses || (exports.NullAddresses = {})); // TypeScript will infer a string union type from the literal values passed to\n// this function. Without `extends string`, it would instead generalize them\n// to the common string type.\n// @see https://stackoverflow.com/questions/36836011/checking-validity-of-string-literal-union-type-at-runtime\n\n\nvar StringUnion = function () {\n  var values = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    values[_i] = arguments[_i];\n  }\n\n  Object.freeze(values);\n  var valueSet = new Set(values);\n\n  var guard = function (value) {\n    return valueSet.has(value);\n  };\n\n  var check = function (value) {\n    if (!guard(value)) {\n      var actual = JSON.stringify(value);\n      var expected = values.map(function (s) {\n        return JSON.stringify(s);\n      }).join(' | ');\n      throw new TypeError(\"Value '\" + actual + \"' is not assignable to type '\" + expected + \"'.\");\n    }\n\n    return value;\n  };\n\n  var unionNamespace = {\n    guard: guard,\n    check: check,\n    values: values\n  };\n  return Object.freeze(unionNamespace);\n};\n\nexports.UnsSupportedNetwork = StringUnion('mainnet', 'rinkeby', 'polygon-mainnet', 'polygon-mumbai');\nexports.ZnsSupportedNetwork = StringUnion('mainnet', 'testnet');\n\nfunction hasProvider(obj) {\n  return obj && !!obj.provider;\n}\n\nexports.hasProvider = hasProvider;","map":{"version":3,"names":["Object","defineProperty","exports","value","NullAddress","NullAddresses","StringUnion","values","_i","arguments","length","freeze","valueSet","Set","guard","has","check","actual","JSON","stringify","expected","map","s","join","TypeError","unionNamespace","UnsSupportedNetwork","ZnsSupportedNetwork","hasProvider","obj","provider"],"sources":["/Users/mac/Desktop/work/wave-frontend/node_modules/@unstoppabledomains/resolution/build/types/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NullAddress = '0x0000000000000000000000000000000000000000';\nvar NullAddresses;\n(function (NullAddresses) {\n    NullAddresses[NullAddresses[\"0x\"] = 0] = \"0x\";\n    NullAddresses[NullAddresses[\"0x0000000000000000000000000000000000000000\"] = 1] = \"0x0000000000000000000000000000000000000000\";\n    NullAddresses[NullAddresses[\"0x0000000000000000000000000000000000000000000000000000000000000000\"] = 2] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n})(NullAddresses = exports.NullAddresses || (exports.NullAddresses = {}));\n// TypeScript will infer a string union type from the literal values passed to\n// this function. Without `extends string`, it would instead generalize them\n// to the common string type.\n// @see https://stackoverflow.com/questions/36836011/checking-validity-of-string-literal-union-type-at-runtime\nvar StringUnion = function () {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    Object.freeze(values);\n    var valueSet = new Set(values);\n    var guard = function (value) {\n        return valueSet.has(value);\n    };\n    var check = function (value) {\n        if (!guard(value)) {\n            var actual = JSON.stringify(value);\n            var expected = values.map(function (s) { return JSON.stringify(s); }).join(' | ');\n            throw new TypeError(\"Value '\" + actual + \"' is not assignable to type '\" + expected + \"'.\");\n        }\n        return value;\n    };\n    var unionNamespace = { guard: guard, check: check, values: values };\n    return Object.freeze(unionNamespace);\n};\nexports.UnsSupportedNetwork = StringUnion('mainnet', 'rinkeby', 'polygon-mainnet', 'polygon-mumbai');\nexports.ZnsSupportedNetwork = StringUnion('mainnet', 'testnet');\nfunction hasProvider(obj) {\n    return obj && !!obj.provider;\n}\nexports.hasProvider = hasProvider;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,WAAR,GAAsB,4CAAtB;AACA,IAAIC,aAAJ;;AACA,CAAC,UAAUA,aAAV,EAAyB;EACtBA,aAAa,CAACA,aAAa,CAAC,IAAD,CAAb,GAAsB,CAAvB,CAAb,GAAyC,IAAzC;EACAA,aAAa,CAACA,aAAa,CAAC,4CAAD,CAAb,GAA8D,CAA/D,CAAb,GAAiF,4CAAjF;EACAA,aAAa,CAACA,aAAa,CAAC,oEAAD,CAAb,GAAsF,CAAvF,CAAb,GAAyG,oEAAzG;AACH,CAJD,EAIGA,aAAa,GAAGH,OAAO,CAACG,aAAR,KAA0BH,OAAO,CAACG,aAAR,GAAwB,EAAlD,CAJnB,E,CAKA;AACA;AACA;AACA;;;AACA,IAAIC,WAAW,GAAG,YAAY;EAC1B,IAAIC,MAAM,GAAG,EAAb;;EACA,KAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;IAC1CD,MAAM,CAACC,EAAD,CAAN,GAAaC,SAAS,CAACD,EAAD,CAAtB;EACH;;EACDR,MAAM,CAACW,MAAP,CAAcJ,MAAd;EACA,IAAIK,QAAQ,GAAG,IAAIC,GAAJ,CAAQN,MAAR,CAAf;;EACA,IAAIO,KAAK,GAAG,UAAUX,KAAV,EAAiB;IACzB,OAAOS,QAAQ,CAACG,GAAT,CAAaZ,KAAb,CAAP;EACH,CAFD;;EAGA,IAAIa,KAAK,GAAG,UAAUb,KAAV,EAAiB;IACzB,IAAI,CAACW,KAAK,CAACX,KAAD,CAAV,EAAmB;MACf,IAAIc,MAAM,GAAGC,IAAI,CAACC,SAAL,CAAehB,KAAf,CAAb;MACA,IAAIiB,QAAQ,GAAGb,MAAM,CAACc,GAAP,CAAW,UAAUC,CAAV,EAAa;QAAE,OAAOJ,IAAI,CAACC,SAAL,CAAeG,CAAf,CAAP;MAA2B,CAArD,EAAuDC,IAAvD,CAA4D,KAA5D,CAAf;MACA,MAAM,IAAIC,SAAJ,CAAc,YAAYP,MAAZ,GAAqB,+BAArB,GAAuDG,QAAvD,GAAkE,IAAhF,CAAN;IACH;;IACD,OAAOjB,KAAP;EACH,CAPD;;EAQA,IAAIsB,cAAc,GAAG;IAAEX,KAAK,EAAEA,KAAT;IAAgBE,KAAK,EAAEA,KAAvB;IAA8BT,MAAM,EAAEA;EAAtC,CAArB;EACA,OAAOP,MAAM,CAACW,MAAP,CAAcc,cAAd,CAAP;AACH,CApBD;;AAqBAvB,OAAO,CAACwB,mBAAR,GAA8BpB,WAAW,CAAC,SAAD,EAAY,SAAZ,EAAuB,iBAAvB,EAA0C,gBAA1C,CAAzC;AACAJ,OAAO,CAACyB,mBAAR,GAA8BrB,WAAW,CAAC,SAAD,EAAY,SAAZ,CAAzC;;AACA,SAASsB,WAAT,CAAqBC,GAArB,EAA0B;EACtB,OAAOA,GAAG,IAAI,CAAC,CAACA,GAAG,CAACC,QAApB;AACH;;AACD5B,OAAO,CAAC0B,WAAR,GAAsBA,WAAtB"},"metadata":{},"sourceType":"script"}