{"ast":null,"code":"\"use strict\";\n/* eslint-disable no-undef */\n\n/**\n * All functionality below came from here https://github.com/Zilliqa/Zilliqa-JavaScript-Library/tree/dev/packages/zilliqa-js-crypto/src\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar js_sha256_1 = require(\"js-sha256\");\n\nvar index_1 = require(\"./index\");\n\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]; // HRP is the human-readable part of zilliqa bech32 addresses\n\nvar HRP = 'zil';\nvar tHRP = 'tzil';\n\nfunction isByteString(str, len) {\n  return !!str.replace('0x', '').match(\"^[0-9a-fA-F]{\" + len + \"}$\");\n}\n\nfunction isAddress(address) {\n  return isByteString(address, 40);\n}\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\n\n\nfunction convertBits(data, fromWidth, toWidth, pad) {\n  if (pad === void 0) {\n    pad = true;\n  }\n\n  var acc = 0;\n  var bits = 0;\n  var ret = [];\n  var maxv = (1 << toWidth) - 1; // tslint:disable-next-line\n\n  for (var p = 0; p < data.length; ++p) {\n    var value = data[p];\n\n    if (value < 0 || value >> fromWidth !== 0) {\n      return null;\n    }\n\n    acc = acc << fromWidth | value;\n    bits += fromWidth;\n\n    while (bits >= toWidth) {\n      bits -= toWidth;\n      ret.push(acc >> bits & maxv);\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      ret.push(acc << toWidth - bits & maxv);\n    }\n  } else if (bits >= fromWidth || acc << toWidth - bits & maxv) {\n    return null;\n  }\n\n  return Buffer.from(ret);\n}\n\nfunction hrpExpand(hrp) {\n  var ret = [];\n  var p;\n\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n\n  ret.push(0);\n\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n\n  return Buffer.from(ret);\n}\n\nfunction polymod(values) {\n  var chk = 1; // tslint:disable-next-line\n\n  for (var p = 0; p < values.length; ++p) {\n    var top_1 = chk >> 25;\n    chk = (chk & 0x1ffffff) << 5 ^ values[p];\n\n    for (var i = 0; i < 5; ++i) {\n      if (top_1 >> i & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n\n  return chk;\n}\n\nfunction createChecksum(hrp, data) {\n  var values = Buffer.concat([Buffer.from(hrpExpand(hrp)), data, Buffer.from([0, 0, 0, 0, 0, 0])]); // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n\n  var mod = polymod(values) ^ 1;\n  var ret = [];\n\n  for (var p = 0; p < 6; ++p) {\n    ret.push(mod >> 5 * (5 - p) & 31);\n  }\n\n  return Buffer.from(ret);\n}\n\nfunction verifyChecksum(hrp, data) {\n  return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\n\nfunction encode(hrp, data) {\n  var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n  var ret = hrp + '1'; // tslint:disable-next-line\n\n  for (var p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n\n  return ret;\n}\n\nfunction decode(bechString) {\n  var p;\n  var hasLower = false;\n  var hasUpper = false;\n\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n      hasLower = true;\n    }\n\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n      hasUpper = true;\n    }\n  }\n\n  if (hasLower && hasUpper) {\n    return null;\n  }\n\n  bechString = bechString.toLowerCase();\n  var pos = bechString.lastIndexOf('1');\n\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n\n  var hrp = bechString.substring(0, pos);\n  var data = [];\n\n  for (p = pos + 1; p < bechString.length; ++p) {\n    var d = CHARSET.indexOf(bechString.charAt(p));\n\n    if (d === -1) {\n      return null;\n    }\n\n    data.push(d);\n  }\n\n  if (!verifyChecksum(hrp, Buffer.from(data))) {\n    return null;\n  }\n\n  return {\n    hrp: hrp,\n    data: Buffer.from(data.slice(0, data.length - 6))\n  };\n}\n/**\n * toChecksumAddress\n *\n * takes hex-encoded string and returns the corresponding address\n * @param {string} address\n * @returns {string}\n */\n\n\nexports.toChecksumAddress = function (address) {\n  if (!isAddress(address)) {\n    throw new Error(address + \" is not a valid base 16 address\");\n  }\n\n  address = address.toLowerCase().replace('0x', '');\n  var hash = js_sha256_1.sha256(index_1.hexToBytes(address));\n  var v = new bn_js_1.default(hash, 'hex', 'be');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if ('0123456789'.indexOf(address[i]) !== -1) {\n      ret += address[i];\n    } else {\n      ret += v.and(new bn_js_1.default(2).pow(new bn_js_1.default(255 - 6 * i))).gte(new bn_js_1.default(1)) ? address[i].toUpperCase() : address[i].toLowerCase();\n    }\n  }\n\n  return ret;\n};\n/**\n * toBech32Address\n *\n * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\n * address.\n *\n * The expected format is zil1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n * @param {string} address 20 byte canonical address\n * @param {boolean} testnet\n * @returns {string} 38 char bech32 encoded zilliqa address\n */\n\n\nfunction toBech32Address(address, testnet) {\n  if (testnet === void 0) {\n    testnet = false;\n  }\n\n  if (!isAddress(address)) {\n    throw new Error('Invalid address format.');\n  }\n\n  var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n\n  if (addrBz === null) {\n    throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n  }\n\n  return encode(testnet ? tHRP : HRP, addrBz);\n}\n\nexports.toBech32Address = toBech32Address;\n/**\n * fromBech32Address\n * @param {string} address - a valid Zilliqa bech32 address\n * @param {boolean} testnet\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\n\nfunction fromBech32Address(address, testnet) {\n  if (testnet === void 0) {\n    testnet = false;\n  }\n\n  var res = decode(address);\n\n  if (res === null) {\n    throw new Error('Invalid bech32 address');\n  }\n\n  var hrp = res.hrp,\n      data = res.data;\n  var shouldBe = testnet ? tHRP : HRP;\n\n  if (hrp !== shouldBe) {\n    throw new Error(\"Expected hrp to be \" + shouldBe + \" but got \" + hrp);\n  }\n\n  var buf = convertBits(data, 5, 8, false);\n\n  if (buf === null) {\n    throw new Error('Could not convert buffer to bytes');\n  }\n\n  return exports.toChecksumAddress(buf.toString('hex'));\n}\n\nexports.fromBech32Address = fromBech32Address;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","bn_js_1","require","js_sha256_1","index_1","CHARSET","GENERATOR","HRP","tHRP","isByteString","str","len","replace","match","isAddress","address","convertBits","data","fromWidth","toWidth","pad","acc","bits","ret","maxv","p","length","push","Buffer","from","hrpExpand","hrp","charCodeAt","polymod","values","chk","top_1","i","createChecksum","concat","verifyChecksum","encode","combined","charAt","decode","bechString","hasLower","hasUpper","toLowerCase","pos","lastIndexOf","substring","d","indexOf","slice","toChecksumAddress","Error","hash","sha256","hexToBytes","v","default","and","pow","gte","toUpperCase","toBech32Address","testnet","addrBz","fromBech32Address","res","shouldBe","buf","toString"],"sources":["/Users/mac/Desktop/work/wave-frontend/node_modules/@unstoppabledomains/resolution/build/utils/znsUtils.js"],"sourcesContent":["\"use strict\";\n/* eslint-disable no-undef */\n/**\n * All functionality below came from here https://github.com/Zilliqa/Zilliqa-JavaScript-Library/tree/dev/packages/zilliqa-js-crypto/src\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar js_sha256_1 = require(\"js-sha256\");\nvar index_1 = require(\"./index\");\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n// HRP is the human-readable part of zilliqa bech32 addresses\nvar HRP = 'zil';\nvar tHRP = 'tzil';\nfunction isByteString(str, len) {\n    return !!str.replace('0x', '').match(\"^[0-9a-fA-F]{\" + len + \"}$\");\n}\nfunction isAddress(address) {\n    return isByteString(address, 40);\n}\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\nfunction convertBits(data, fromWidth, toWidth, pad) {\n    if (pad === void 0) { pad = true; }\n    var acc = 0;\n    var bits = 0;\n    var ret = [];\n    var maxv = (1 << toWidth) - 1;\n    // tslint:disable-next-line\n    for (var p = 0; p < data.length; ++p) {\n        var value = data[p];\n        if (value < 0 || value >> fromWidth !== 0) {\n            return null;\n        }\n        acc = (acc << fromWidth) | value;\n        bits += fromWidth;\n        while (bits >= toWidth) {\n            bits -= toWidth;\n            ret.push((acc >> bits) & maxv);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            ret.push((acc << (toWidth - bits)) & maxv);\n        }\n    }\n    else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {\n        return null;\n    }\n    return Buffer.from(ret);\n}\nfunction hrpExpand(hrp) {\n    var ret = [];\n    var p;\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) >> 5);\n    }\n    ret.push(0);\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) & 31);\n    }\n    return Buffer.from(ret);\n}\nfunction polymod(values) {\n    var chk = 1;\n    // tslint:disable-next-line\n    for (var p = 0; p < values.length; ++p) {\n        var top_1 = chk >> 25;\n        chk = ((chk & 0x1ffffff) << 5) ^ values[p];\n        for (var i = 0; i < 5; ++i) {\n            if ((top_1 >> i) & 1) {\n                chk ^= GENERATOR[i];\n            }\n        }\n    }\n    return chk;\n}\nfunction createChecksum(hrp, data) {\n    var values = Buffer.concat([\n        Buffer.from(hrpExpand(hrp)),\n        data,\n        Buffer.from([0, 0, 0, 0, 0, 0]),\n    ]);\n    // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n    var mod = polymod(values) ^ 1;\n    var ret = [];\n    for (var p = 0; p < 6; ++p) {\n        ret.push((mod >> (5 * (5 - p))) & 31);\n    }\n    return Buffer.from(ret);\n}\nfunction verifyChecksum(hrp, data) {\n    return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\nfunction encode(hrp, data) {\n    var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n    var ret = hrp + '1';\n    // tslint:disable-next-line\n    for (var p = 0; p < combined.length; ++p) {\n        ret += CHARSET.charAt(combined[p]);\n    }\n    return ret;\n}\nfunction decode(bechString) {\n    var p;\n    var hasLower = false;\n    var hasUpper = false;\n    for (p = 0; p < bechString.length; ++p) {\n        if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n            return null;\n        }\n        if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n            hasLower = true;\n        }\n        if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n            hasUpper = true;\n        }\n    }\n    if (hasLower && hasUpper) {\n        return null;\n    }\n    bechString = bechString.toLowerCase();\n    var pos = bechString.lastIndexOf('1');\n    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n        return null;\n    }\n    var hrp = bechString.substring(0, pos);\n    var data = [];\n    for (p = pos + 1; p < bechString.length; ++p) {\n        var d = CHARSET.indexOf(bechString.charAt(p));\n        if (d === -1) {\n            return null;\n        }\n        data.push(d);\n    }\n    if (!verifyChecksum(hrp, Buffer.from(data))) {\n        return null;\n    }\n    return { hrp: hrp, data: Buffer.from(data.slice(0, data.length - 6)) };\n}\n/**\n * toChecksumAddress\n *\n * takes hex-encoded string and returns the corresponding address\n * @param {string} address\n * @returns {string}\n */\nexports.toChecksumAddress = function (address) {\n    if (!isAddress(address)) {\n        throw new Error(address + \" is not a valid base 16 address\");\n    }\n    address = address.toLowerCase().replace('0x', '');\n    var hash = js_sha256_1.sha256(index_1.hexToBytes(address));\n    var v = new bn_js_1.default(hash, 'hex', 'be');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if ('0123456789'.indexOf(address[i]) !== -1) {\n            ret += address[i];\n        }\n        else {\n            ret += v.and(new bn_js_1.default(2).pow(new bn_js_1.default(255 - 6 * i))).gte(new bn_js_1.default(1))\n                ? address[i].toUpperCase()\n                : address[i].toLowerCase();\n        }\n    }\n    return ret;\n};\n/**\n * toBech32Address\n *\n * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\n * address.\n *\n * The expected format is zil1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n * @param {string} address 20 byte canonical address\n * @param {boolean} testnet\n * @returns {string} 38 char bech32 encoded zilliqa address\n */\nfunction toBech32Address(address, testnet) {\n    if (testnet === void 0) { testnet = false; }\n    if (!isAddress(address)) {\n        throw new Error('Invalid address format.');\n    }\n    var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n    if (addrBz === null) {\n        throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n    }\n    return encode(testnet ? tHRP : HRP, addrBz);\n}\nexports.toBech32Address = toBech32Address;\n/**\n * fromBech32Address\n * @param {string} address - a valid Zilliqa bech32 address\n * @param {boolean} testnet\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\nfunction fromBech32Address(address, testnet) {\n    if (testnet === void 0) { testnet = false; }\n    var res = decode(address);\n    if (res === null) {\n        throw new Error('Invalid bech32 address');\n    }\n    var hrp = res.hrp, data = res.data;\n    var shouldBe = testnet ? tHRP : HRP;\n    if (hrp !== shouldBe) {\n        throw new Error(\"Expected hrp to be \" + shouldBe + \" but got \" + hrp);\n    }\n    var buf = convertBits(data, 5, 8, false);\n    if (buf === null) {\n        throw new Error('Could not convert buffer to bytes');\n    }\n    return exports.toChecksumAddress(buf.toString('hex'));\n}\nexports.fromBech32Address = fromBech32Address;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}