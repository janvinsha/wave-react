{"ast":null,"code":"!function (e, r) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? r(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], r) : r((e || self).UAuthCommon = {});\n}(this, function (e) {\n  var r = /*#__PURE__*/function () {\n    function e(r) {\n      void 0 === r && (r = e.defaultCreateUrl), this.createURL = void 0, this.createURL = r;\n    }\n\n    return e.defaultCreateUrl = function (e, r) {\n      return \"https://\" + e + \".ipns.dweb.link\" + r.replace(/^\\/?/, \"/\");\n    }, e.prototype.resolve = function (e) {\n      try {\n        var r, n, t;\n        if (e.startsWith(\"/ipfs/\") || e.startsWith(\"/ipns/\")) t = e.substring(1, 5), r = e.substring(6).split(\"/\")[0], n = e.substring(6 + r.length);else {\n          var o = new URL(e);\n          if (\"\" !== o.hash || \"\" !== o.password || \"\" !== o.port || \"\" !== o.search || \"\" !== o.username) throw new Error(\"invalid ipfs uri\");\n          t = o.protocol.substring(0, 4), r = o.hostname, n = o.pathname;\n        }\n        if (\"ipfs\" !== t) throw new Error(\"only ipfs is supported, (not ipns)\");\n        return Promise.resolve(fetch(this.createURL(r, n)).then(function (e) {\n          return e.ok ? e.text() : Promise.reject(new Error(\"bad response\"));\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, e;\n  }(),\n      n = /*#__PURE__*/function () {\n    function e(e) {\n      this.options = void 0, this.options = e;\n    }\n\n    return e.prototype.resolve = function (e, r) {\n      try {\n        var n,\n            t = \"\";\n\n        if (e.includes(\"@\")) {\n          var o = e.split(\"@\", 1);\n          t = o[0], n = o[1];\n        } else n = e;\n\n        var i = \"http://openid.net/specs/connect/1.0/issuer\";\n        return Promise.resolve(this.options.webfingerResolver.resolve(n, t, i, r)).then(function (e) {\n          var r,\n              n = null == (r = e.links) ? void 0 : r.find(function (e) {\n            return e.rel === i;\n          });\n          if (!n || !n.href) throw new Error(\"bad jrd\");\n          return Promise.resolve(fetch(n.href + \"/.well-known/openid-configuration\").then(function (e) {\n            return e.ok ? e.json() : Promise.reject(new Error(\"bad openid-configuration response\"));\n          }));\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, e;\n  }();\n\n  function t(e, r, n) {\n    if (!e.s) {\n      if (n instanceof o) {\n        if (!n.s) return void (n.o = t.bind(null, e, r));\n        1 & r && (r = n.s), n = n.v;\n      }\n\n      if (n && n.then) return void n.then(t.bind(null, e, r), t.bind(null, e, 2));\n      e.s = r, e.v = n;\n      const i = e.o;\n      i && i(e);\n    }\n  }\n\n  var o = /*#__PURE__*/function () {\n    function e() {}\n\n    return e.prototype.then = function (r, n) {\n      var o = new e(),\n          i = this.s;\n\n      if (i) {\n        var s = 1 & i ? r : n;\n\n        if (s) {\n          try {\n            t(o, 1, s(this.v));\n          } catch (e) {\n            t(o, 2, e);\n          }\n\n          return o;\n        }\n\n        return this;\n      }\n\n      return this.o = function (e) {\n        try {\n          var i = e.v;\n          1 & e.s ? t(o, 1, r ? r(i) : i) : n ? t(o, 1, n(i)) : t(o, 2, i);\n        } catch (e) {\n          t(o, 2, e);\n        }\n      }, o;\n    }, e;\n  }();\n\n  if (\"undefined\" != typeof window) {\n    var i = window;\n    i.UAUTH_VERSION = i.UAUTH_VERSION || {}, i.UAUTH_VERSION.COMMON = \"2.2.0\";\n  }\n\n  var s = /*#__PURE__*/function () {\n    function e(e) {\n      this.options = void 0, this.options = e;\n    }\n\n    return e.prototype.resolve = function (e, r, n, i) {\n      try {\n        var s = this,\n            u = \"webfinger.\" + r + \".\" + n;\n        return Promise.resolve(s.options.domainResolver.records(e, [u])).then(function (f) {\n          function a(e) {\n            if (h.subject !== c) throw new Error(\"resource invalid\");\n            return h;\n          }\n\n          var c = r ? \"acct:\" + r + \"@\" + e : \"\" + e;\n          if (!f[u]) return {\n            subject: c,\n            links: [{\n              rel: n,\n              href: i\n            }]\n          };\n          var h,\n              v = JSON.parse(f[u]),\n              l = \"string\" == typeof v.host ? Promise.resolve(fetch(\"/.well-known/webfinger?\" + new URLSearchParams({\n            resource: c,\n            rel: n\n          }).toString(), {\n            headers: {\n              Host: v.host\n            }\n          }).then(function (e) {\n            return e.ok ? e.json() : Promise.reject(new Error(\"bad webfinger response\"));\n          })).then(function (e) {\n            h = e;\n          }) : function () {\n            if (\"string\" == typeof v.uri) {\n              var e = new URL(v.uri);\n              return function (e, r) {\n                var n,\n                    i = -1;\n\n                e: {\n                  for (var s = 0; s < r.length; s++) {\n                    var u = r[s][0];\n\n                    if (u) {\n                      var f = u();\n                      if (f && f.then) break e;\n\n                      if (f === e) {\n                        i = s;\n                        break;\n                      }\n                    } else i = s;\n                  }\n\n                  if (-1 !== i) {\n                    do {\n                      for (var a = r[i][1]; !a;) i++, a = r[i][1];\n\n                      var c = a();\n\n                      if (c && c.then) {\n                        n = !0;\n                        break e;\n                      }\n\n                      var h = r[i][2];\n                      i++;\n                    } while (h && !h());\n\n                    return c;\n                  }\n                }\n\n                var v = new o(),\n                    l = t.bind(null, v, 2);\n                return (n ? c.then(p) : f.then(function n(o) {\n                  for (;;) {\n                    if (o === e) {\n                      i = s;\n                      break;\n                    }\n\n                    if (++s === r.length) {\n                      if (-1 !== i) break;\n                      return void t(v, 1, a);\n                    }\n\n                    if (u = r[s][0]) {\n                      if ((o = u()) && o.then) return void o.then(n).then(void 0, l);\n                    } else i = s;\n                  }\n\n                  do {\n                    for (var f = r[i][1]; !f;) i++, f = r[i][1];\n\n                    var a = f();\n                    if (a && a.then) return void a.then(p).then(void 0, l);\n                    var c = r[i][2];\n                    i++;\n                  } while (c && !c());\n\n                  t(v, 1, a);\n                })).then(void 0, l), v;\n\n                function p(e) {\n                  for (;;) {\n                    var n = r[i][2];\n                    if (!n || n()) break;\n                    i++;\n\n                    for (var o = r[i][1]; !o;) i++, o = r[i][1];\n\n                    if ((e = o()) && e.then) return void e.then(p).then(void 0, l);\n                  }\n\n                  t(v, 1, e);\n                }\n              }(e.protocol, [[function () {\n                return \"http:\";\n              }], [function () {\n                return \"https:\";\n              }, function () {\n                return Promise.resolve(fetch(e.toString()).then(function (e) {\n                  return e.ok ? e.json() : Promise.reject(new Error(\"bad webfinger response\"));\n                })).then(function (e) {\n                  h = e;\n                });\n              }], [function () {\n                return \"ipfs:\";\n              }, function () {\n                return Promise.resolve(s.options.ipfsResolver.resolve(v.uri)).then(function (e) {\n                  h = JSON.parse(e);\n                });\n              }], [function () {\n                return \"ipns:\";\n              }], [function () {\n                return \"swarm:\";\n              }], [void 0, function () {\n                throw new Error(\"uri scheme not supported\");\n              }]]);\n            }\n\n            if (\"string\" != typeof v.value) throw new Error(\"bad webfinger record\");\n            h = JSON.parse(v.value);\n          }();\n          return l && l.then ? l.then(a) : a();\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, e;\n  }();\n\n  function u() {\n    return u = Object.assign || function (e) {\n      for (var r = 1; r < arguments.length; r++) {\n        var n = arguments[r];\n\n        for (var t in n) Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);\n      }\n\n      return e;\n    }, u.apply(this, arguments);\n  }\n\n  var f = /*#__PURE__*/function () {\n    function e() {\n      var e = this;\n      this.map = new Map(), this.records = function (r, n) {\n        try {\n          var t = e.map.get(r);\n          if (0 === n.length) throw new Error(\"no keys\");\n          return Promise.resolve(t ? n.reduce(function (e, r) {\n            return e[r] = t[r] || \"\", e;\n          }, {}) : {});\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      };\n    }\n\n    return e.prototype.set = function (e, r) {\n      this.map.has(e) ? this.map.set(e, u({}, this.map.get(e), r)) : this.map.set(e, r);\n    }, e;\n  }(),\n      a = /*#__PURE__*/function () {\n    function e() {\n      this.map = new Map();\n    }\n\n    var r = e.prototype;\n    return r.set = function (e, r, n, t) {\n      this.map.set(e + \".\" + r + \".\" + n, t);\n    }, r.resolve = function (e, r, n, t) {\n      try {\n        var o = this.map.get(e + \".\" + r + \".\" + n);\n        return Promise.resolve(o || {\n          subject: e,\n          links: [{\n            rel: n,\n            href: t\n          }]\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, e;\n  }();\n\n  e.DefaultIPFSResolver = r, e.DefaultIssuerResolver = n, e.DefaultWebFingerResolver = s, e.MemoryDomainResolver = f, e.MemoryWebFingerResolver = a, e.isJRD = function (e) {\n    return !0;\n  }, e.isJRDLink = function (e) {\n    return !0;\n  };\n});","map":{"version":3,"mappings":"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","names":["DefaultIPFSResolver","createURL","defaultCreateUrl","this","r","cid","e","replace","n","t","resolve","uri","path","startsWith","split","substring","URL","hash","length","o","url","password","port","username","Error","protocol","hostname","Promise","then","fetch","text","reject","DefaultIssuerResolver","options","fallbackIssuer","domain","includes","webfingerResolver","user","_jrd$links","link","jrd","links","find","v","rel","href","value","pact","s","_settle","state","bind","observer","_Pact","prototype","onRejected","callback","result","i","_this","_w","window","UAUTH_VERSION","COMMON","DefaultWebFingerResolver","_this2","records","domainResolver","subject","resource","u","webfingerKey","h","webfingerRecord","parse","toString","URLSearchParams","headers","Host","host","_fetch$then","json","_fetch$then2","ipfsResolver","JSON","_this$options$ipfsRes","_temp2","MemoryDomainResolver","map","Map","keys","reduce","a","set","has","_extends","MemoryWebFingerResolver","document","get"],"sources":["../src/DefaultIPFSResolver.ts","../src/DefaultIssuerResolver.ts","../src/DefaultWebFingerResolver.ts","../src/version.ts","../src/MemoryDomainResolver.ts","../src/MemoryWebFingerResolver.ts","../src/JRD.ts"],"sourcesContent":["import {IPFSResolver} from './types'\n\nexport default class DefaultIPFSResolver implements IPFSResolver {\n  static defaultCreateUrl(cid: string, path: string): string {\n    return `https://${cid}.ipns.dweb.link${path.replace(/^\\/?/, '/')}`\n  }\n\n  constructor(public createURL = DefaultIPFSResolver.defaultCreateUrl) {}\n\n  async resolve(uri: string): Promise<string> {\n    let cid: string\n    let path: string\n    let protocol: string\n\n    if (uri.startsWith('/ipfs/') || uri.startsWith('/ipns/')) {\n      protocol = uri.substring(1, 5)\n      cid = uri.substring(6).split('/')[0]\n      path = uri.substring(6 + cid.length)\n    } else {\n      const url = new URL(uri)\n\n      if (\n        url.hash !== '' ||\n        url.password !== '' ||\n        url.port !== '' ||\n        url.search !== '' ||\n        url.username !== ''\n      ) {\n        throw new Error('invalid ipfs uri')\n      }\n\n      protocol = url.protocol.substring(0, 4)\n      cid = url.hostname\n      path = url.pathname\n    }\n\n    if (protocol !== 'ipfs') {\n      throw new Error('only ipfs is supported, (not ipns)')\n    }\n\n    return fetch(this.createURL(cid, path)).then(resp =>\n      resp.ok ? resp.text() : Promise.reject(new Error('bad response')),\n    )\n  }\n}\n","import {IssuerResolver, IssuerResolverOptions} from './types'\n\nexport default class DefaultIssuerResolver implements IssuerResolver {\n  constructor(public options: IssuerResolverOptions) {}\n\n  async resolve(username: string, fallbackIssuer: string) {\n    let user = ''\n    let domain: string\n    if (username.includes('@')) {\n      ;[user, domain] = username.split('@', 1)\n    } else {\n      domain = username\n    }\n\n    const rel = 'http://openid.net/specs/connect/1.0/issuer'\n\n    const jrd = await this.options.webfingerResolver.resolve(\n      domain,\n      user,\n      rel,\n      fallbackIssuer,\n    )\n\n    const link = jrd.links?.find(v => v.rel === rel)\n    if (!link || !link.href) {\n      throw new Error('bad jrd')\n    }\n\n    const config = await fetch(\n      link.href + '/.well-known/openid-configuration',\n    ).then(resp =>\n      resp.ok\n        ? resp.json()\n        : Promise.reject(new Error('bad openid-configuration response')),\n    )\n\n    return config\n  }\n}\n","import {isJRD} from './JRD'\nimport {JRDDocument, WebFingerRecord, WebFingerResolverOptions} from './types'\nimport {VERSION} from './version'\n\nif (typeof window !== 'undefined') {\n  const _w = window as any\n  _w.UAUTH_VERSION = _w.UAUTH_VERSION || {}\n  _w.UAUTH_VERSION.COMMON = VERSION\n}\n\nexport default class DefaultWebFingerResolver {\n  constructor(public options: WebFingerResolverOptions) {}\n\n  async resolve(\n    domain: string,\n    user: string,\n    rel: string,\n    fallbackIssuer: string,\n  ): Promise<JRDDocument> {\n    const webfingerKey = `webfinger.${user}.${rel}`\n\n    // console.log('domain:', domain)\n    // console.log('webfingerKey:', webfingerKey)\n\n    const records = await this.options.domainResolver.records(domain, [\n      webfingerKey,\n    ])\n\n    const resource = user ? `acct:${user}@${domain}` : `${domain}`\n\n    // console.log('record value:', records[webfingerKey])\n\n    if (!records[webfingerKey]) {\n      return {subject: resource, links: [{rel, href: fallbackIssuer}]}\n    }\n\n    const webfingerRecord: WebFingerRecord = JSON.parse(records[webfingerKey])\n\n    // console.log('webfingerRecord:', webfingerRecord)\n\n    let json\n    if (typeof webfingerRecord.host === 'string') {\n      json = await fetch(\n        '/.well-known/webfinger?' +\n          new URLSearchParams({resource, rel}).toString(),\n        {headers: {Host: webfingerRecord.host}},\n      ).then(resp =>\n        resp.ok\n          ? resp.json()\n          : Promise.reject(new Error('bad webfinger response')),\n      )\n    } else if (typeof webfingerRecord.uri === 'string') {\n      const url = new URL(webfingerRecord.uri)\n\n      switch (url.protocol) {\n        case 'http:':\n        case 'https:': {\n          json = await fetch(url.toString()).then(resp =>\n            resp.ok\n              ? resp.json()\n              : Promise.reject(new Error('bad webfinger response')),\n          )\n          break\n        }\n        case 'ipfs:': {\n          json = JSON.parse(\n            await this.options.ipfsResolver.resolve(webfingerRecord.uri),\n          )\n          break\n        }\n        case 'ipns:':\n        case 'swarm:':\n        default: {\n          throw new Error('uri scheme not supported')\n        }\n      }\n    } else if (typeof webfingerRecord.value === 'string') {\n      json = JSON.parse(webfingerRecord.value)\n    } else {\n      throw new Error('bad webfinger record')\n    }\n\n    if (!isJRD(json)) {\n      throw new Error('resolved document not jrd')\n    }\n\n    if (json.subject !== resource) {\n      throw new Error('resource invalid')\n    }\n\n    return json\n  }\n}\n","export const VERSION = \"2.2.0\";\n","import {DomainResolver} from './types'\n\nexport default class MemoryDomainResolver implements DomainResolver {\n  private map: Map<string, Record<string, string>> = new Map()\n\n  set(domain: string, records: Record<string, string>): void {\n    if (!this.map.has(domain)) {\n      this.map.set(domain, records)\n      return\n    }\n\n    this.map.set(domain, {...this.map.get(domain), ...records})\n  }\n\n  records = async (\n    domain: string,\n    keys: string[],\n  ): Promise<Record<string, string>> => {\n    const records = this.map.get(domain)\n\n    if (keys.length === 0) {\n      throw new Error('no keys')\n    }\n\n    if (!records) {\n      return {}\n    }\n\n    return keys.reduce((a, v) => {\n      a[v] = records[v] || ''\n      return a\n    }, {} as Record<string, string>)\n  }\n}\n","import {JRDDocument, WebFingerResolver} from './types'\n\nexport default class MemoryWebFingerResolver implements WebFingerResolver {\n  map = new Map<string, JRDDocument>()\n\n  set(domain: string, user: string, rel: string, document: JRDDocument): void {\n    this.map.set(`${domain}.${user}.${rel}`, document)\n  }\n\n  async resolve(\n    domain: string,\n    user: string,\n    rel: string,\n    fallbackIssuer: string,\n  ): Promise<JRDDocument> {\n    const jrd = this.map.get(`${domain}.${user}.${rel}`)\n\n    if (!jrd) {\n      return {subject: domain, links: [{rel, href: fallbackIssuer}]}\n    }\n\n    return jrd\n  }\n}\n","import {JRDDocument, JRDLink} from './types'\n\nexport function isJRDLink(json: any): json is JRDLink {\n  return true\n}\n\nexport function isJRD(json: any): json is JRDDocument {\n  return true\n}\n"]},"metadata":{},"sourceType":"script"}